diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index 7ff419e..4313d59 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -1,99 +1,100 @@
-/*
- * j1939.h
- *
- * Copyright (c) 2010-2011 EIA Electronics
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef _J1939_H_
-#define _J1939_H_
-
-#include <linux/types.h>
-#include <linux/socket.h>
-#include <linux/can.h>
-
-#define J1939_IDLE_ADDR	0xfe
-#define J1939_NO_ADDR	0xff
-#define J1939_NO_NAME	0
-#define J1939_NO_PGN	0x40000
-/*
- * J1939 Parameter Group Number
- *
- * bit 0-7	: PDU Specific (PS)
- * bit 8-15	: PDU Format (PF)
- * bit 16	: Data Page (DP)
- * bit 17	: Reserved (R)
- * bit 19-31	: set to zero
- */
-typedef __u32 pgn_t;
-
-/*
- * J1939 Priority
- *
- * bit 0-2	: Priority (P)
- * bit 3-7	: set to zero
- */
-typedef __u8 priority_t;
-
-/*
- * J1939 NAME
- *
- * bit 0-20	: Identity Number
- * bit 21-31	: Manufacturer Code
- * bit 32-34	: ECU Instance
- * bit 35-39	: Function Instance
- * bit 40-47	: Function
- * bit 48	: Reserved
- * bit 49-55	: Vehicle System
- * bit 56-59	: Vehicle System Instance
- * bit 60-62	: Industry Group
- * bit 63	: Arbitrary Address Capable
- */
-typedef __u64 name_t;
-
-/*
- * J1939 socket options
- */
-#define SOL_CAN_J1939 (SOL_CAN_BASE + CAN_J1939)
-enum {
-	SO_J1939_FILTER = 1,	/* set filters */
-	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
-	SO_J1939_RECV_OWN = 3,
-	SO_J1939_SEND_PRIO = 4,
-};
-
-enum {
-	SCM_J1939_DEST_ADDR = 1,
-	SCM_J1939_DEST_NAME = 2,
-	SCM_J1939_PRIO = 3,
-};
-
-struct j1939_filter {
-	name_t name;
-	name_t name_mask;
-	__u8 addr;
-	__u8 addr_mask;
-	pgn_t pgn;
-	pgn_t pgn_mask;
-};
-
-/*
- * RTNETLINK
- */
-enum {
-	IFLA_J1939_UNSPEC,
-	IFLA_J1939_ENABLE,
-	IFLA_J1939_MAX,
-};
-
-enum {
-	IFA_J1939_UNSPEC,
-	IFA_J1939_ADDR,
-	IFA_J1939_NAME,
-	IFA_J1939_MAX,
-};
-
-#endif /* _J1939_H_ */
+/*
+ * j1939.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _J1939_H_
+#define _J1939_H_
+
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/can.h>
+
+#define J1939_IDLE_ADDR	0xfe
+#define J1939_NO_ADDR	0xff
+#define J1939_NO_NAME	0
+#define J1939_NO_PGN	0x40000
+/*
+ * J1939 Parameter Group Number
+ *
+ * bit 0-7	: PDU Specific (PS)
+ * bit 8-15	: PDU Format (PF)
+ * bit 16	: Data Page (DP)
+ * bit 17	: Reserved (R)
+ * bit 19-31	: set to zero
+ */
+typedef __u32 pgn_t;
+
+/*
+ * J1939 Priority
+ *
+ * bit 0-2	: Priority (P)
+ * bit 3-7	: set to zero
+ */
+typedef __u8 priority_t;
+
+/*
+ * J1939 NAME
+ *
+ * bit 0-20	: Identity Number
+ * bit 21-31	: Manufacturer Code
+ * bit 32-34	: ECU Instance
+ * bit 35-39	: Function Instance
+ * bit 40-47	: Function
+ * bit 48	: Reserved
+ * bit 49-55	: Vehicle System
+ * bit 56-59	: Vehicle System Instance
+ * bit 60-62	: Industry Group
+ * bit 63	: Arbitrary Address Capable
+ */
+typedef __u64 name_t;
+
+/*
+ * J1939 socket options
+ */
+#define SOL_CAN_J1939 (SOL_CAN_BASE + CAN_J1939)
+enum {
+	SO_J1939_FILTER = 1,	/* set filters */
+	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
+	SO_J1939_RECV_OWN = 3,
+	SO_J1939_SEND_PRIO = 4,
+	SO_J1939_BAM_DELAY_DISABLE = 5, //Enable/Disable 50 ms delay for BAM messages
+};
+
+enum {
+	SCM_J1939_DEST_ADDR = 1,
+	SCM_J1939_DEST_NAME = 2,
+	SCM_J1939_PRIO = 3,
+};
+
+struct j1939_filter {
+	name_t name;
+	name_t name_mask;
+	__u8 addr;
+	__u8 addr_mask;
+	pgn_t pgn;
+	pgn_t pgn_mask;
+};
+
+/*
+ * RTNETLINK
+ */
+enum {
+	IFLA_J1939_UNSPEC,
+	IFLA_J1939_ENABLE,
+	IFLA_J1939_MAX,
+};
+
+enum {
+	IFA_J1939_UNSPEC,
+	IFA_J1939_ADDR,
+	IFA_J1939_NAME,
+	IFA_J1939_MAX,
+};
+
+#endif /* _J1939_H_ */
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 5adc8bf..11d0c6c 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -1,315 +1,338 @@
-/*
- * j1939-priv.h
- *
- * Copyright (c) 2010-2011 EIA Electronics
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef _J1939_PRIV_H_
-#define _J1939_PRIV_H_
-
-#include <linux/kref.h>
-#include <linux/list.h>
-#include <net/sock.h>
-
-#include <linux/seq_file.h>
-#include <linux/proc_fs.h>
-#include <linux/module.h>
-#include <linux/can/j1939.h>
-#include <linux/atomic.h>
-#include <linux/interrupt.h>
-
-/* TODO: return ENETRESET on busoff. */
-
-#define ECUFLAG_LOCAL	0x01
-#define ECUFLAG_REMOTE	0x02
-
-#define PGN_REQUEST		0x0ea00
-#define PGN_ADDRESS_CLAIMED	0x0ee00
-#define PGN_MAX			0x3ffff
-
-#define SA_MAX_UNICAST	0xfd
-/*
- * j1939 devices
- */
-struct j1939_ecu {
-	struct list_head list;
-	ktime_t rxtime;
-	name_t name;
-	int flags;
-	uint8_t sa;
-	/*
-	 * atomic flag, set by ac_timer
-	 * cleared/processed by segment's tasklet
-	 * indicates that this ecu successfully claimed @sa as its address
-	 * By communicating this from the ac_timer event to segments tasklet,
-	 * a context locking problem is solved. All other 'ecu readers'
-	 * must only lock with _bh, not with _irq.
-	 */
-	atomic_t ac_delay_expired;
-	struct hrtimer ac_timer;
-	struct kref kref;
-	struct j1939_segment *parent;
-};
-#define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
-
-struct j1939_segment {
-	struct list_head ecus; /*
-	 * local list entry in parent
-	 * These allow irq (& softirq) context lookups on j1939 devices
-	 * This approach (seperate lists) is done as the other 2 alternatives
-	 * are not easier or even wrong
-	 * 1) using the pure kobject methods involves mutexes, which are not
-	 *    allowed in irq context.
-	 * 2) duplicating data structures would require a lot of synchronization
-	 *    code
-	 * usage:
-	 */
-	rwlock_t lock; /*
-	 * segments need a lock to protect the above list
-	 */
-	struct list_head flist; /*
-	 * list entry for use by interrupt lookup routines
-	 */
-	int ifindex;
-	struct addr_ent {
-		ktime_t rxtime;
-		struct j1939_ecu *ecu;
-		int flags;
-	} ents[256];
-
-	/*
-	 * tasklet to process ecu address claimed events.
-	 * These events raise in hardirq context. Signalling the event
-	 * and scheduling this tasklet successfully moves the
-	 * event to softirq context
-	 */
-	struct tasklet_struct ac_task;
-	/*
-	 * list of 256 ecu ptrs, that cache the claimed addresses.
-	 * also protected by the above lock
-	 * don't use directly, use j1939_ecu_set_address() instead
-	 */
-	struct kref kref;
-};
-#define to_j1939_segment(x) container_of((x), struct j1939_segment, dev)
-
-extern void put_j1939_ecu(struct j1939_ecu *ecu);
-extern void put_j1939_segment(struct j1939_segment *segment);
-static inline struct j1939_ecu *get_j1939_ecu(struct j1939_ecu *dut)
-{
-	kref_get(&dut->kref);
-	return dut;
-}
-static inline struct j1939_segment *get_j1939_segment(struct j1939_segment *dut)
-{
-	kref_get(&dut->kref);
-	return dut;
-}
-
-/*
- * conversion function between (struct sock | struct sk_buff)->sk_priority
- * from linux and j1939 priority field
- */
-static inline int j1939_prio(int sk_priority)
-{
-	if (sk_priority < 0)
-		return 6; /* default */
-	else if (sk_priority > 7)
-		return 0;
-	else
-		return 7 - sk_priority;
-}
-static inline int j1939_to_sk_priority(int j1939_prio)
-{
-	return 7 - j1939_prio;
-}
-
-static inline int j1939_address_is_valid(uint8_t sa)
-{
-	return sa != J1939_NO_ADDR;
-}
-
-static inline int j1939_address_is_unicast(uint8_t sa)
-{
-	return sa <= SA_MAX_UNICAST;
-}
-
-static inline int pgn_is_pdu1(pgn_t pgn)
-{
-	/* ignore dp & res bits for this */
-	return (pgn & 0xff00) < 0xf000;
-}
-
-static inline int pgn_is_valid(pgn_t pgn)
-{
-	return pgn <= PGN_MAX;
-}
-
-/* utility to correctly unregister a SA */
-static inline void j1939_ecu_remove_sa_locked(struct j1939_ecu *ecu)
-{
-	if (!j1939_address_is_unicast(ecu->sa))
-		return;
-	if (ecu->parent->ents[ecu->sa].ecu == ecu)
-		ecu->parent->ents[ecu->sa].ecu = NULL;
-}
-
-static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
-{
-	if (!j1939_address_is_unicast(ecu->sa))
-		return;
-	write_lock_bh(&ecu->parent->lock);
-	j1939_ecu_remove_sa_locked(ecu);
-	write_unlock_bh(&ecu->parent->lock);
-}
-
-extern int j1939_name_to_sa(uint64_t name, int ifindex);
-extern struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
-extern struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
-/* find_by_name, with kref & read_lock taken */
-extern struct j1939_ecu *j1939_ecu_find_segment_default_tx(
-		int ifindex, name_t *pname, uint8_t *paddr);
-
-extern void j1939_put_promisc_receiver(int ifindex);
-extern void j1939_get_promisc_receiver(int ifindex);
-
-extern int j1939_proc_add(const char *file,
-		int (*seq_show)(struct seq_file *sqf, void *v),
-		write_proc_t write);
-extern void j1939_proc_remove(const char *file);
-
-extern const char j1939_procname[];
-/* j1939 printk */
-#define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
-
-#define j1939_err(...)		j1939_printk(KERN_ERR , __VA_ARGS__)
-#define j1939_warning(...)	j1939_printk(KERN_WARNING , __VA_ARGS__)
-#define j1939_notice(...)	j1939_printk(KERN_NOTICE , __VA_ARGS__)
-#define j1939_info(...)		j1939_printk(KERN_INFO , __VA_ARGS__)
-#ifdef DEBUG
-#define j1939_debug(...)	j1939_printk(KERN_DEBUG , __VA_ARGS__)
-#else
-#define j1939_debug(...)
-#endif
-
-struct sk_buff;
-
-/* control buffer of the sk_buff */
-struct j1939_sk_buff_cb {
-	int ifindex;
-	priority_t priority;
-	struct {
-		name_t name;
-		uint8_t addr;
-		int flags;
-	} src, dst;
-	pgn_t pgn;
-	int msg_flags;
-	/* for tx, MSG_SYN will be used to sync on sockets */
-};
-#define J1939_MSG_RESERVED	MSG_SYN
-#define J1939_MSG_SYNC		MSG_SYN
-
-static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *cb)
-{
-	return (!cb->dst.name && (cb->dst.addr >= 0xff));
-}
-
-/* J1939 stack */
-enum {
-	j1939_level_can,
-	j1939_level_transport,
-	j1939_level_sky,
-};
-
-#define RESULT_STOP	1
-/*
- * return RESULT_STOP when stack processing may stop.
- * it is up to the stack entry itself to kfree_skb() the sk_buff
- */
-
-extern int j1939_send(struct sk_buff *, int level);
-extern int j1939_recv(struct sk_buff *, int level);
-
-/* stack entries */
-extern int j1939_recv_promisc(struct sk_buff *);
-extern int j1939_send_transport(struct sk_buff *);
-extern int j1939_recv_transport(struct sk_buff *);
-extern int j1939_send_address_claim(struct sk_buff *);
-extern int j1939_recv_address_claim(struct sk_buff *);
-
-extern int j1939_recv_distribute(struct sk_buff *);
-
-/* network management */
-/*
- * j1939_ecu_get_register
- * 'create' & 'register' & 'get' new ecu
- * when a matching ecu already exists, the behaviour depends
- * on @return_existing.
- * when @return_existing is 0, -EEXISTS is returned
- * when @return_exsiting is 1, that ecu is 'get' & returned.
- * @flags is only used when creating new ecu.
- */
-extern struct j1939_ecu *j1939_ecu_get_register(name_t name, int ifindex,
-		int flags, int return_existing);
-extern void j1939_ecu_unregister(struct j1939_ecu *);
-
-extern int j1939_segment_attach(struct net_device *);
-extern int j1939_segment_detach(struct net_device *);
-
-extern int j1939_segment_register(struct net_device *);
-extern void j1939_segment_unregister(struct j1939_segment *);
-extern struct j1939_segment *j1939_segment_find(int ifindex);
-
-extern void j1939sk_netdev_event(int ifindex, int error_code);
-
-/* add/remove receiver */
-extern int j1939_recv_add(void *vp, void (*fn)(struct sk_buff *, void *));
-extern int j1939_recv_remove(void *vp, void (*fn)(struct sk_buff *, void *));
-
-/*
- * provide public access to this lock
- * so sparse can verify the context balance
- */
-extern rwlock_t j1939_receiver_rwlock;
-static inline void j1939_recv_suspend(void)
-{
-	write_lock_bh(&j1939_receiver_rwlock);
-}
-
-static inline void j1939_recv_resume(void)
-{
-	write_unlock_bh(&j1939_receiver_rwlock);
-}
-
-/* locks the recv module */
-extern void j1939_recv_suspend(void);
-extern void j1939_recv_resume(void);
-
-/*
- * decrement pending skb for a j1939 socket
- */
-extern void j1939_sock_pending_del(struct sock *sk);
-
-/* seperate module-init/modules-exit's */
-extern __init int j1939_proc_module_init(void);
-extern __init int j1939bus_module_init(void);
-extern __init int j1939sk_module_init(void);
-extern __init int j1939tp_module_init(void);
-
-extern void j1939_proc_module_exit(void);
-extern void j1939bus_module_exit(void);
-extern void j1939sk_module_exit(void);
-extern void j1939tp_module_exit(void);
-
-/* rtnetlink */
-extern const struct rtnl_af_ops j1939_rtnl_af_ops;
-extern int j1939rtnl_new_addr(struct sk_buff *, struct nlmsghdr *, void *arg);
-extern int j1939rtnl_del_addr(struct sk_buff *, struct nlmsghdr *, void *arg);
-extern int j1939rtnl_dump_addr(struct sk_buff *, struct netlink_callback *);
-
-#endif /* _J1939_PRIV_H_ */
+/*
+ * j1939-priv.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _J1939_PRIV_H_
+#define _J1939_PRIV_H_
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <net/sock.h>
+
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <linux/can/j1939.h>
+#include <linux/atomic.h>
+#include <linux/interrupt.h>
+
+/* TODO: return ENETRESET on busoff. */
+
+#define ECUFLAG_LOCAL	0x01
+#define ECUFLAG_REMOTE	0x02
+
+#define PGN_REQUEST		0x0ea00
+#define PGN_ADDRESS_CLAIMED	0x0ee00
+#define PGN_MAX			0x3ffff
+
+#define SA_MAX_UNICAST	0xfd
+/*
+ * j1939 devices
+ */
+struct j1939_ecu {
+	struct list_head list;
+	ktime_t rxtime;
+	name_t name;
+	int flags;
+	uint8_t sa;
+	/*
+	 * atomic flag, set by ac_timer
+	 * cleared/processed by segment's tasklet
+	 * indicates that this ecu successfully claimed @sa as its address
+	 * By communicating this from the ac_timer event to segments tasklet,
+	 * a context locking problem is solved. All other 'ecu readers'
+	 * must only lock with _bh, not with _irq.
+	 */
+	atomic_t ac_delay_expired;
+	struct hrtimer ac_timer;
+	struct kref kref;
+	struct j1939_segment *parent;
+};
+#define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
+
+struct j1939_segment {
+	struct list_head ecus; /*
+	 * local list entry in parent
+	 * These allow irq (& softirq) context lookups on j1939 devices
+	 * This approach (seperate lists) is done as the other 2 alternatives
+	 * are not easier or even wrong
+	 * 1) using the pure kobject methods involves mutexes, which are not
+	 *    allowed in irq context.
+	 * 2) duplicating data structures would require a lot of synchronization
+	 *    code
+	 * usage:
+	 */
+	rwlock_t lock; /*
+	 * segments need a lock to protect the above list
+	 */
+	struct list_head flist; /*
+	 * list entry for use by interrupt lookup routines
+	 */
+	int ifindex;
+	struct addr_ent {
+		ktime_t rxtime;
+		struct j1939_ecu *ecu;
+		int flags;
+	} ents[256];
+
+	/*
+	 * tasklet to process ecu address claimed events.
+	 * These events raise in hardirq context. Signalling the event
+	 * and scheduling this tasklet successfully moves the
+	 * event to softirq context
+	 */
+	struct tasklet_struct ac_task;
+	/*
+	 * list of 256 ecu ptrs, that cache the claimed addresses.
+	 * also protected by the above lock
+	 * don't use directly, use j1939_ecu_set_address() instead
+	 */
+	struct kref kref;
+};
+#define to_j1939_segment(x) container_of((x), struct j1939_segment, dev)
+
+extern void put_j1939_ecu(struct j1939_ecu *ecu);
+extern void put_j1939_segment(struct j1939_segment *segment);
+static inline struct j1939_ecu *get_j1939_ecu(struct j1939_ecu *dut)
+{
+	kref_get(&dut->kref);
+	return dut;
+}
+static inline struct j1939_segment *get_j1939_segment(struct j1939_segment *dut)
+{
+	kref_get(&dut->kref);
+	return dut;
+}
+
+/*
+ * conversion function between (struct sock | struct sk_buff)->sk_priority
+ * from linux and j1939 priority field
+ */
+static inline int j1939_prio(int sk_priority)
+{
+	if (sk_priority < 0)
+		return 6; /* default */
+	else if (sk_priority > 7)
+		return 0;
+	else
+		return 7 - sk_priority;
+}
+static inline int j1939_to_sk_priority(int j1939_prio)
+{
+	return 7 - j1939_prio;
+}
+
+static inline int j1939_address_is_valid(uint8_t sa)
+{
+	return sa != J1939_NO_ADDR;
+}
+
+static inline int j1939_address_is_unicast(uint8_t sa)
+{
+	return sa <= SA_MAX_UNICAST;
+}
+
+static inline int pgn_is_pdu1(pgn_t pgn)
+{
+	/* ignore dp & res bits for this */
+	return (pgn & 0xff00) < 0xf000;
+}
+
+static inline int pgn_is_valid(pgn_t pgn)
+{
+	return pgn <= PGN_MAX;
+}
+
+/* utility to correctly unregister a SA */
+static inline void j1939_ecu_remove_sa_locked(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	if (ecu->parent->ents[ecu->sa].ecu == ecu)
+		ecu->parent->ents[ecu->sa].ecu = NULL;
+}
+
+static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	write_lock_bh(&ecu->parent->lock);
+	j1939_ecu_remove_sa_locked(ecu);
+	write_unlock_bh(&ecu->parent->lock);
+}
+
+extern int j1939_name_to_sa(uint64_t name, int ifindex);
+extern struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
+extern struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
+/* find_by_name, with kref & read_lock taken */
+extern struct j1939_ecu *j1939_ecu_find_segment_default_tx(
+		int ifindex, name_t *pname, uint8_t *paddr);
+
+extern void j1939_put_promisc_receiver(int ifindex);
+extern void j1939_get_promisc_receiver(int ifindex);
+
+extern int j1939_proc_add(const char *file,
+		int (*seq_show)(struct seq_file *sqf, void *v),
+		write_proc_t write);
+extern void j1939_proc_remove(const char *file);
+
+extern const char j1939_procname[];
+/* j1939 printk */
+#define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
+
+#define j1939_err(...)		j1939_printk(KERN_ERR , __VA_ARGS__)
+#define j1939_warning(...)	j1939_printk(KERN_WARNING , __VA_ARGS__)
+#define j1939_notice(...)	j1939_printk(KERN_NOTICE , __VA_ARGS__)
+#define j1939_info(...)		j1939_printk(KERN_INFO , __VA_ARGS__)
+#ifdef DEBUG
+#define j1939_debug(...)	j1939_printk(KERN_DEBUG , __VA_ARGS__)
+#else
+#define j1939_debug(...)
+#endif
+
+struct sk_buff;
+
+/* control buffer of the sk_buff */
+struct j1939_sk_buff_cb {
+	int ifindex;
+	priority_t priority;
+	struct {
+		name_t name;
+		uint8_t addr;
+		int flags;
+	} src, dst;
+	pgn_t pgn;
+	int msg_flags;
+	/* for tx, MSG_SYN will be used to sync on sockets */
+};
+#define J1939_MSG_RESERVED	MSG_SYN
+#define J1939_MSG_SYNC		MSG_SYN
+
+
+struct j1939_tp_mod
+{
+	int tpflags; 				//Flags for modifying the trasnport protocol
+	#define BAM_NODELAY 	1	//One such flag
+};
+
+//Check if we want to disable the normal BAM 50 ms delay
+//Return 0 if we want to disable the delay
+//Return 1 if we want to keep the delay
+static inline int j1939cb_use_bamdelay(const struct j1939_tp_mod *tpmod)
+{
+	printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	printk(KERN_ALERT "DEBUG: skcb->tpflags state: %d\n",tpmod->tpflags);
+
+	if(tpmod->tpflags & BAM_NODELAY)
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *cb)
+{
+	return (!cb->dst.name && (cb->dst.addr >= 0xff));
+}
+
+/* J1939 stack */
+enum {
+	j1939_level_can,
+	j1939_level_transport,
+	j1939_level_sky,
+};
+
+#define RESULT_STOP	1
+/*
+ * return RESULT_STOP when stack processing may stop.
+ * it is up to the stack entry itself to kfree_skb() the sk_buff
+ */
+
+extern int j1939_send(struct sk_buff *, int level);
+extern int j1939_recv(struct sk_buff *, int level);
+
+/* stack entries */
+extern int j1939_recv_promisc(struct sk_buff *);
+extern int j1939_send_transport(struct sk_buff *);
+extern int j1939_recv_transport(struct sk_buff *);
+extern int j1939_send_address_claim(struct sk_buff *);
+extern int j1939_recv_address_claim(struct sk_buff *);
+
+extern int j1939_recv_distribute(struct sk_buff *);
+
+/* network management */
+/*
+ * j1939_ecu_get_register
+ * 'create' & 'register' & 'get' new ecu
+ * when a matching ecu already exists, the behaviour depends
+ * on @return_existing.
+ * when @return_existing is 0, -EEXISTS is returned
+ * when @return_exsiting is 1, that ecu is 'get' & returned.
+ * @flags is only used when creating new ecu.
+ */
+extern struct j1939_ecu *j1939_ecu_get_register(name_t name, int ifindex,
+		int flags, int return_existing);
+extern void j1939_ecu_unregister(struct j1939_ecu *);
+
+extern int j1939_segment_attach(struct net_device *);
+extern int j1939_segment_detach(struct net_device *);
+
+extern int j1939_segment_register(struct net_device *);
+extern void j1939_segment_unregister(struct j1939_segment *);
+extern struct j1939_segment *j1939_segment_find(int ifindex);
+
+extern void j1939sk_netdev_event(int ifindex, int error_code);
+
+/* add/remove receiver */
+extern int j1939_recv_add(void *vp, void (*fn)(struct sk_buff *, void *));
+extern int j1939_recv_remove(void *vp, void (*fn)(struct sk_buff *, void *));
+
+/*
+ * provide public access to this lock
+ * so sparse can verify the context balance
+ */
+extern rwlock_t j1939_receiver_rwlock;
+static inline void j1939_recv_suspend(void)
+{
+	write_lock_bh(&j1939_receiver_rwlock);
+}
+
+static inline void j1939_recv_resume(void)
+{
+	write_unlock_bh(&j1939_receiver_rwlock);
+}
+
+/* locks the recv module */
+extern void j1939_recv_suspend(void);
+extern void j1939_recv_resume(void);
+
+/*
+ * decrement pending skb for a j1939 socket
+ */
+extern void j1939_sock_pending_del(struct sock *sk);
+
+/* seperate module-init/modules-exit's */
+extern __init int j1939_proc_module_init(void);
+extern __init int j1939bus_module_init(void);
+extern __init int j1939sk_module_init(void);
+extern __init int j1939tp_module_init(void);
+
+extern void j1939_proc_module_exit(void);
+extern void j1939bus_module_exit(void);
+extern void j1939sk_module_exit(void);
+extern void j1939tp_module_exit(void);
+
+/* rtnetlink */
+extern const struct rtnl_af_ops j1939_rtnl_af_ops;
+extern int j1939rtnl_new_addr(struct sk_buff *, struct nlmsghdr *, void *arg);
+extern int j1939rtnl_del_addr(struct sk_buff *, struct nlmsghdr *, void *arg);
+extern int j1939rtnl_dump_addr(struct sk_buff *, struct netlink_callback *);
+
+#endif /* _J1939_PRIV_H_ */
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index a00fab1..40ac1fd 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -1,984 +1,1004 @@
-/*
- * Copyright (c) 2010-2011 EIA Electronics
- *
- * Authors:
- * Kurt Van Dijck <kurt.van.dijck@eia.be>
- * Pieter Beyens <pieter.beyens@eia.be>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the version 2 of the GNU General Public License
- * as published by the Free Software Foundation
- */
-
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/socket.h>
-#include <linux/list.h>
-#include <linux/if_arp.h>
-#include <net/tcp_states.h>
-
-#include <linux/can/core.h>
-#include <linux/can/j1939.h>
-#include "j1939-priv.h"
-
-struct j1939_sock {
-	struct sock sk; /* must be first to skip with memset */
-	struct list_head list;
-
-	int state;
-	#define JSK_BOUND	BIT(0)
-	#define JSK_CONNECTED	BIT(1)
-	#define PROMISC		BIT(2)
-	#define RECV_OWN	BIT(3)
-
-	struct {
-		name_t src, dst;
-		pgn_t pgn;
-
-		uint8_t sa, da;
-	} addr;
-
-	struct j1939_filter *filters;
-	int nfilters;
-
-	int skb_pending;
-	spinlock_t lock;
-	wait_queue_head_t waitq;
-};
-
-static inline struct j1939_sock *j1939_sk(const struct sock *sk)
-{
-	return container_of(sk, struct j1939_sock, sk);
-}
-
-/* skb_pending issues */
-static inline int j1939_sock_pending_add_first(struct sock *sk)
-{
-	int saved;
-	struct j1939_sock *jsk = j1939_sk(sk);
-
-	spin_lock_bh(&jsk->lock);
-	if (!jsk->skb_pending) {
-		++jsk->skb_pending;
-		saved = 1;
-	} else
-		saved = 0;
-	spin_unlock_bh(&jsk->lock);
-	return saved;
-}
-
-static inline void j1939_sock_pending_add(struct sock *sk)
-{
-	struct j1939_sock *jsk = j1939_sk(sk);
-
-	spin_lock_bh(&jsk->lock);
-	++jsk->skb_pending;
-	spin_unlock_bh(&jsk->lock);
-}
-
-void j1939_sock_pending_del(struct sock *sk)
-{
-	struct j1939_sock *jsk = j1939_sk(sk);
-	int saved;
-
-	spin_lock_bh(&jsk->lock);
-	--jsk->skb_pending;
-	saved = jsk->skb_pending;
-	spin_unlock_bh(&jsk->lock);
-	if (!saved)
-		wake_up(&jsk->waitq);
-}
-
-
-static inline int j1939_no_address(const struct sock *sk)
-{
-	const struct j1939_sock *jsk = j1939_sk(sk);
-	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src;
-}
-
-/*
- * list of sockets
- */
-static struct {
-	struct mutex lock;
-	struct list_head socks;
-} s;
-
-/* matches skb control buffer (addr) with a j1939 filter */
-static inline int packet_match(const struct j1939_sk_buff_cb *cb,
-		const struct j1939_filter *f, int nfilter)
-{
-	if (!nfilter)
-		/* receive all when no filters are assigned */
-		return 1;
-	/*
-	 * Filters relying on the addr for static addressing _should_ get
-	 * packets from dynamic addressed ECU's too if they match their SA.
-	 * Sockets using dynamic addressing in their filters should not set it.
-	 */
-	for (; nfilter; ++f, --nfilter) {
-		if ((cb->pgn & f->pgn_mask) != (f->pgn & f->pgn_mask))
-			continue;
-		if ((cb->src.addr & f->addr_mask) != (f->addr & f->addr_mask))
-			continue;
-		if ((cb->src.name & f->name_mask) != (f->name & f->name_mask))
-			continue;
-		return 1;
-	}
-	return 0;
-}
-
-/*
- * callback per socket, called from filter infrastructure
- */
-static void j1939sk_recv_skb(struct sk_buff *oskb, void *data)
-{
-	struct sk_buff *skb;
-	struct j1939_sock *jsk = (struct j1939_sock *)data;
-	struct j1939_sk_buff_cb *cb = (void *)oskb->cb;
-
-	if (jsk->sk.sk_bound_dev_if && (jsk->sk.sk_bound_dev_if != cb->ifindex))
-		/* this socket does not take packets from this iface */
-		return;
-	if (!(jsk->state & PROMISC)) {
-		if (cb->dst.flags & ECUFLAG_REMOTE)
-			/*
-			 * this msg was destined for an ECU associated
-			 * with this socket
-			 */
-			return;
-		if (jsk->addr.src) {
-			if (cb->dst.name &&
-				(cb->dst.name != jsk->addr.src))
-				/*
-				 * the msg is not destined for the name
-				 * that the socket is bound to
-				 */
-				return;
-		} else if (j1939_address_is_unicast(jsk->addr.sa)) {
-			if (j1939_address_is_unicast(cb->dst.addr) &&
-				(cb->dst.addr != jsk->addr.sa))
-				/*
-				 * the msg is not destined for the name
-				 * that the socket is bound to
-				 */
-				return;
-		}
-	}
-
-	if ((oskb->sk == &jsk->sk) && !(jsk->state & RECV_OWN))
-		/* own message */
-		return;
-
-	if (!packet_match(cb, jsk->filters, jsk->nfilters))
-		return;
-
-	skb = skb_clone(oskb, GFP_ATOMIC);
-	if (!skb) {
-		j1939_warning("skb clone failed\n");
-		return;
-	}
-	cb = (void *)skb->cb;
-	cb->msg_flags &= ~(MSG_DONTROUTE | MSG_CONFIRM);
-	if (oskb->sk)
-		cb->msg_flags |= MSG_DONTROUTE;
-	if (oskb->sk == &jsk->sk)
-		cb->msg_flags |= MSG_CONFIRM;
-
-	skb->sk = &jsk->sk;
-	if (sock_queue_rcv_skb(&jsk->sk, skb) < 0)
-		kfree_skb(skb);
-}
-
-static int j1939sk_init(struct sock *sk)
-{
-	struct j1939_sock *jsk = j1939_sk(sk);
-
-	INIT_LIST_HEAD(&jsk->list);
-	spin_lock_init(&jsk->lock);
-	init_waitqueue_head(&jsk->waitq);
-	jsk->sk.sk_priority = j1939_to_sk_priority(6);
-	jsk->sk.sk_reuse = 1; /* per default */
-	jsk->addr.sa = J1939_NO_ADDR;
-	jsk->addr.da = J1939_NO_ADDR;
-	return 0;
-}
-
-/*
- * helper: return <0 for error, >0 for error to notify
- */
-static int j1939sk_bind_netdev_helper(struct socket *sock)
-{
-	struct j1939_sock *jsk = j1939_sk(sock->sk);
-	int ret;
-	struct net_device *netdev;
-	struct j1939_segment *jseg;
-
-	if (!jsk->sk.sk_bound_dev_if)
-		return 0;
-	ret = 0;
-
-	netdev = dev_get_by_index(&init_net, jsk->sk.sk_bound_dev_if);
-	if (!netdev) {
-		ret = -ENODEV;
-		goto fail_netdev;
-	}
-
-	/* no need to test for CAN device,
-	 * implicitely done by j1939_segment
-	 */
-	jseg = j1939_segment_find(netdev->ifindex);
-	if (!jseg) {
-		ret = -EHOSTDOWN;
-		goto fail_segment;
-	}
-
-	if (!(netdev->flags & IFF_UP)) {
-		sock->sk->sk_err = ENETDOWN;
-		sock->sk->sk_error_report(sock->sk);
-	}
-	put_j1939_segment(jseg);
-fail_segment:
-	dev_put(netdev);
-fail_netdev:
-	return ret;
-}
-
-static int j1939sk_bind_addr_helper(int ifindex, uint8_t addr)
-{
-	struct j1939_segment *jseg;
-	struct addr_ent *paddr;
-	int flags;
-
-	/* static addressing, netdev is required */
-	if (!ifindex)
-		return -EINVAL;
-
-	jseg = j1939_segment_find(ifindex);
-	if (!jseg)
-		return -ENETUNREACH;
-	paddr = &jseg->ents[addr];
-	read_lock_bh(&jseg->lock);
-	flags = paddr->flags;
-	read_unlock_bh(&jseg->lock);
-	put_j1939_segment(jseg);
-	if (!(flags & ECUFLAG_LOCAL))
-		return -EADDRNOTAVAIL;
-	return 0;
-}
-
-static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
-{
-	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
-	struct j1939_sock *jsk = j1939_sk(sock->sk);
-	int ret, old_state;
-
-	if (len < required_size(can_addr.j1939, *addr))
-		return -EINVAL;
-	if (addr->can_family != AF_CAN)
-		return -EINVAL;
-
-	/* lock s.lock first, to avoid circular lock dependancy */
-	mutex_lock(&s.lock);
-	lock_sock(sock->sk);
-	if (jsk->state & JSK_BOUND) {
-		ret = -EBUSY;
-		if (addr->can_ifindex &&
-				(addr->can_ifindex != jsk->sk.sk_bound_dev_if))
-			goto fail_locked;
-		if (jsk->addr.src &&
-				(jsk->addr.src == addr->can_addr.j1939.name)) {
-			/*
-			 * allow to change the address after the first bind()
-			 * when using dynamic addressing
-			 */
-			/* set to be able to send address claims */
-			jsk->addr.sa = addr->can_addr.j1939.addr;
-		} else if (jsk->addr.sa == addr->can_addr.j1939.addr) {
-			/* no change */
-		} else if (j1939_address_is_unicast(addr->can_addr.j1939.addr)) {
-			/* change of static source address */
-			ret = j1939sk_bind_addr_helper(jsk->sk.sk_bound_dev_if,
-					addr->can_addr.j1939.addr);
-			if (ret < 0)
-				goto fail_locked;
-			jsk->addr.sa = addr->can_addr.j1939.addr;
-		} else {
-			goto fail_locked;
-		}
-		/* set default transmit pgn */
-		jsk->addr.pgn = addr->can_addr.j1939.pgn;
-		/* since this socket is bound already, we can skip a lot */
-		release_sock(sock->sk);
-		mutex_unlock(&s.lock);
-		return 0;
-	}
-
-	/* do netdev */
-	if (jsk->sk.sk_bound_dev_if && addr->can_ifindex &&
-			(jsk->sk.sk_bound_dev_if != addr->can_ifindex)) {
-		ret = -EBADR;
-		goto fail_locked;
-	}
-	if (!jsk->sk.sk_bound_dev_if)
-		jsk->sk.sk_bound_dev_if = addr->can_ifindex;
-
-	ret = j1939sk_bind_netdev_helper(sock);
-	if (ret < 0)
-		goto fail_locked;
-
-	/* bind name/addr */
-	if (addr->can_addr.j1939.name) {
-		struct j1939_ecu *ecu;
-
-		ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
-				jsk->sk.sk_bound_dev_if);
-		if (!ecu || IS_ERR(ecu)) {
-			ret = -EADDRNOTAVAIL;
-			goto fail_locked;
-		} else if (ecu->flags & ECUFLAG_REMOTE) {
-			ret = -EREMOTE;
-			put_j1939_ecu(ecu);
-			goto fail_locked;
-		} else if (jsk->sk.sk_bound_dev_if != ecu->parent->ifindex) {
-			ret = -EHOSTUNREACH;
-			put_j1939_ecu(ecu);
-			goto fail_locked;
-		}
-		jsk->addr.src = ecu->name;
-		jsk->addr.sa = addr->can_addr.j1939.addr;
-		put_j1939_ecu(ecu);
-	} else if (j1939_address_is_unicast(addr->can_addr.j1939.addr)) {
-		ret = j1939sk_bind_addr_helper(jsk->sk.sk_bound_dev_if,
-				addr->can_addr.j1939.addr);
-		if (ret < 0)
-			goto fail_locked;
-		jsk->addr.sa = addr->can_addr.j1939.addr;
-	} else if (addr->can_addr.j1939.addr == J1939_IDLE_ADDR) {
-		/* static addressing, netdev is required */
-		if (!jsk->sk.sk_bound_dev_if) {
-			ret = -EINVAL;
-			goto fail_locked;
-		}
-		jsk->addr.sa = addr->can_addr.j1939.addr;
-	} else {
-		/* no name, no addr */
-	}
-
-	/* set default transmit pgn */
-	jsk->addr.pgn = addr->can_addr.j1939.pgn;
-
-	old_state = jsk->state;
-	jsk->state |= JSK_BOUND;
-
-	if (!(old_state & (JSK_BOUND | JSK_CONNECTED))) {
-		list_add_tail(&jsk->list, &s.socks);
-		j1939_recv_add(jsk, j1939sk_recv_skb);
-	}
-
-	ret = 0;
-
-fail_locked:
-	release_sock(sock->sk);
-	mutex_unlock(&s.lock);
-	return ret;
-}
-
-static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
-		int len, int flags)
-{
-	int ret, old_state;
-	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
-	struct j1939_sock *jsk = j1939_sk(sock->sk);
-	struct j1939_ecu *ecu;
-	int ifindex;
-
-	if (!uaddr)
-		return -EDESTADDRREQ;
-
-	if (len < required_size(can_addr.j1939, *addr))
-		return -EINVAL;
-	if (addr->can_family != AF_CAN)
-		return -EINVAL;
-
-	mutex_lock(&s.lock);
-	lock_sock(sock->sk);
-	if (jsk->state & JSK_CONNECTED) {
-		ret = -EISCONN;
-		goto fail_locked;
-	}
-
-	ifindex = jsk->sk.sk_bound_dev_if;
-	if (ifindex && addr->can_ifindex && (ifindex != addr->can_ifindex)) {
-		ret = -ECONNREFUSED;
-		goto fail_locked;
-	}
-	if (!ifindex)
-		ifindex = addr->can_ifindex;
-
-	/* lookup destination */
-	if (addr->can_addr.j1939.name) {
-		ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
-				ifindex);
-		if (!ecu) {
-			ret = -EADDRNOTAVAIL;
-			goto fail_locked;
-		}
-		if (ifindex && (ifindex != ecu->parent->ifindex)) {
-			ret = -EHOSTUNREACH;
-			goto fail_locked;
-		}
-		ifindex = ecu->parent->ifindex;
-		jsk->addr.dst = ecu->name;
-		jsk->addr.da = ecu->sa;
-		put_j1939_ecu(ecu);
-	} else {
-		/* broadcast */
-		jsk->addr.dst = 0;
-		jsk->addr.da = addr->can_addr.j1939.addr;
-	}
-	/*
-	 * take a default source when not present, so connected sockets
-	 * will stick to the same source ECU
-	 */
-	if (!jsk->addr.src && !j1939_address_is_valid(jsk->addr.sa)) {
-		ecu = j1939_ecu_find_segment_default_tx(ifindex,
-				&jsk->addr.src, &jsk->addr.sa);
-		if (IS_ERR(ecu)) {
-			ret = PTR_ERR(ecu);
-			goto fail_locked;
-		}
-		put_j1939_ecu(ecu);
-	}
-
-	/* start assigning, no problem can occur at this point anymore */
-	jsk->sk.sk_bound_dev_if = ifindex;
-
-	if (!(jsk->state & JSK_BOUND) || !pgn_is_valid(jsk->addr.pgn)) {
-		/*
-		 * bind() takes precedence over connect() for the
-		 * pgn to use ourselve
-		 */
-		jsk->addr.pgn = addr->can_addr.j1939.pgn;
-	}
-
-	old_state = jsk->state;
-	jsk->state |= JSK_CONNECTED;
-
-	if (!(old_state & (JSK_BOUND | JSK_CONNECTED))) {
-		list_add_tail(&jsk->list, &s.socks);
-		j1939_recv_add(jsk, j1939sk_recv_skb);
-	}
-	release_sock(sock->sk);
-	mutex_unlock(&s.lock);
-	return 0;
-
-fail_locked:
-	release_sock(sock->sk);
-	mutex_unlock(&s.lock);
-	return ret;
-}
-
-static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
-		const struct j1939_sock *jsk, int peer)
-{
-	addr->can_family = AF_CAN;
-	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
-	addr->can_addr.j1939.name = peer ? jsk->addr.dst : jsk->addr.src;
-	addr->can_addr.j1939.pgn = jsk->addr.pgn;
-	addr->can_addr.j1939.addr = peer ? jsk->addr.da : jsk->addr.sa;
-}
-
-static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
-		int *len, int peer)
-{
-	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
-	struct sock *sk = sock->sk;
-	struct j1939_sock *jsk = j1939_sk(sk);
-	int ret = 0;
-
-	lock_sock(sk);
-
-	if (peer && !(jsk->state & JSK_CONNECTED)) {
-		ret = -EADDRNOTAVAIL;
-		goto failure;
-	}
-
-	j1939sk_sock2sockaddr_can(addr, jsk, peer);
-	*len = sizeof(*addr);
-
-failure:
-	release_sock(sk);
-
-	return ret;
-}
-
-static int j1939sk_release(struct socket *sock)
-{
-	struct sock *sk = sock->sk;
-	struct j1939_sock *jsk;
-
-	if (!sk)
-		return 0;
-	jsk = j1939_sk(sk);
-	j1939_recv_remove(jsk, j1939sk_recv_skb);
-	mutex_lock(&s.lock);
-	list_del_init(&jsk->list);
-	mutex_unlock(&s.lock);
-
-	lock_sock(sk);
-	if (jsk->state & PROMISC)
-		j1939_put_promisc_receiver(jsk->sk.sk_bound_dev_if);
-
-	sock_orphan(sk);
-	sock->sk = NULL;
-
-	release_sock(sk);
-	sock_put(sk);
-
-	return 0;
-}
-
-static int j1939sk_setsockopt_flag(struct j1939_sock *jsk,
-		char __user *optval, unsigned int optlen, int flag)
-{
-	int tmp;
-
-	if (optlen != sizeof(tmp))
-		return -EINVAL;
-	if (copy_from_user(&tmp, optval, optlen))
-		return -EFAULT;
-	lock_sock(&jsk->sk);
-	if (tmp)
-		jsk->state |= flag;
-	else
-		jsk->state &= ~flag;
-	release_sock(&jsk->sk);
-	return tmp;
-}
-
-static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
-		char __user *optval, unsigned int optlen)
-{
-	struct sock *sk = sock->sk;
-	struct j1939_sock *jsk = j1939_sk(sk);
-	int ret = 0, tmp, count;
-	struct j1939_filter *filters, *ofilters;
-
-	if (level != SOL_CAN_J1939)
-		return -EINVAL;
-
-	switch (optname) {
-	case SO_J1939_FILTER:
-		if (optval) {
-			if (optlen % sizeof(*filters) != 0)
-				return -EINVAL;
-			count = optlen / sizeof(*filters);
-			filters = kmalloc(optlen, GFP_KERNEL);
-			if (!filters)
-				return -ENOMEM;
-			if (copy_from_user(filters, optval, optlen)) {
-				kfree(filters);
-				return -EFAULT;
-			}
-		} else {
-			filters = NULL;
-			count = 0;
-		}
-
-		j1939_recv_suspend();
-		ofilters = jsk->filters;
-		jsk->filters = filters;
-		jsk->nfilters = count;
-		j1939_recv_resume();
-		if (ofilters)
-			kfree(ofilters);
-		break;
-	case SO_J1939_PROMISC:
-		tmp = jsk->state & PROMISC;
-		ret = j1939sk_setsockopt_flag(jsk, optval, optlen, PROMISC);
-		if (ret && !tmp)
-			j1939_get_promisc_receiver(jsk->sk.sk_bound_dev_if);
-		else if (!ret && tmp)
-			j1939_put_promisc_receiver(jsk->sk.sk_bound_dev_if);
-		ret = 0;
-		break;
-	case SO_J1939_RECV_OWN:
-		j1939sk_setsockopt_flag(jsk, optval, optlen, RECV_OWN);
-		break;
-	case SO_J1939_SEND_PRIO:
-		if (optlen != sizeof(tmp))
-			return -EINVAL;
-		if (copy_from_user(&tmp, optval, optlen))
-			return -EFAULT;
-		if ((tmp < 0) || (tmp > 7))
-			return -EDOM;
-		if ((tmp < 2) && !capable(CAP_NET_ADMIN))
-			return -EPERM;
-		lock_sock(&jsk->sk);
-		jsk->sk.sk_priority = j1939_to_sk_priority(tmp);
-		release_sock(&jsk->sk);
-		break;
-	default:
-		return -ENOPROTOOPT;
-	}
-
-	return ret;
-}
-
-static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
-		char __user *optval, int __user *optlen)
-{
-	struct sock *sk = sock->sk;
-	struct j1939_sock *jsk = j1939_sk(sk);
-	int ret, ulen;
-	/* set defaults for using 'int' properties */
-	int tmp = 0;
-	int len = sizeof(tmp);
-	void *val = &tmp;
-
-	if (level != SOL_CAN_J1939)
-		return -EINVAL;
-	if (get_user(ulen, optlen))
-		return -EFAULT;
-	if (ulen < 0)
-		return -EINVAL;
-
-	lock_sock(&jsk->sk);
-	switch (optname) {
-	case SO_J1939_PROMISC:
-		tmp = (jsk->state & PROMISC) ? 1 : 0;
-		break;
-	case SO_J1939_RECV_OWN:
-		tmp = (jsk->state & RECV_OWN) ? 1 : 0;
-		break;
-	case SO_J1939_SEND_PRIO:
-		tmp = j1939_prio(jsk->sk.sk_priority);
-		break;
-	default:
-		ret = -ENOPROTOOPT;
-		goto no_copy;
-	}
-
-	/*
-	 * copy to user, based on 'len' & 'val'
-	 * but most sockopt's are 'int' properties, and have 'len' & 'val'
-	 * left unchanged, but instead modified 'tmp'
-	 */
-	if (len > ulen)
-		ret = -EFAULT;
-	else if (put_user(len, optlen))
-		ret = -EFAULT;
-	else if (copy_to_user(optval, val, len))
-		ret = -EFAULT;
-	else
-		ret = 0;
-no_copy:
-	release_sock(&jsk->sk);
-	return ret;
-}
-
-static int j1939sk_recvmsg(struct kiocb *iocb, struct socket *sock,
-			 struct msghdr *msg, size_t size, int flags)
-{
-	struct sock *sk = sock->sk;
-	struct sk_buff *skb;
-	struct j1939_sk_buff_cb *sk_addr;
-	int ret = 0;
-
-	skb = skb_recv_datagram(sk, flags, 0, &ret);
-	if (!skb)
-		return ret;
-
-	if (size < skb->len)
-		msg->msg_flags |= MSG_TRUNC;
-	else
-		size = skb->len;
-
-	ret = memcpy_toiovec(msg->msg_iov, skb->data, size);
-	if (ret < 0)
-		goto failed_with_skb;
-
-	sock_recv_timestamp(msg, sk, skb);
-	sk_addr = (void *)skb->cb;
-
-	if (j1939_address_is_valid(sk_addr->dst.addr))
-		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
-				sizeof(sk_addr->dst.addr), &sk_addr->dst.addr);
-
-	if (sk_addr->dst.name)
-		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,
-				sizeof(sk_addr->dst.name), &sk_addr->dst.name);
-
-	put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,
-			sizeof(sk_addr->priority), &sk_addr->priority);
-
-	if (msg->msg_name) {
-		struct sockaddr_can *paddr = msg->msg_name;
-
-		msg->msg_namelen = required_size(can_addr.j1939, *paddr);
-		memset(msg->msg_name, 0, msg->msg_namelen);
-		paddr->can_family = AF_CAN;
-		paddr->can_ifindex = sk_addr->ifindex;
-		paddr->can_addr.j1939.name = sk_addr->src.name;
-		paddr->can_addr.j1939.addr = sk_addr->src.addr;
-		paddr->can_addr.j1939.pgn = sk_addr->pgn;
-	}
-
-	msg->msg_flags |= sk_addr->msg_flags;
-	skb_free_datagram(sk, skb);
-
-	return size;
-
-failed_with_skb:
-	skb_kill_datagram(sk, skb, flags);
-	return ret;
-}
-
-static int j1939sk_sendmsg(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *msg, size_t size)
-{
-	struct sock *sk = sock->sk;
-	struct j1939_sock *jsk = j1939_sk(sk);
-	struct j1939_sk_buff_cb *skb_cb;
-	struct sk_buff *skb;
-	struct net_device *dev;
-	struct j1939_ecu *ecu;
-	int ifindex;
-	int ret;
-
-	if (!(jsk->state & JSK_BOUND))
-		return -ENOTCONN;
-
-	if (msg->msg_name && (msg->msg_namelen <
-			required_size(can_addr.j1939, struct sockaddr_can)))
-		return -EINVAL;
-
-	ifindex = jsk->sk.sk_bound_dev_if;
-	if (msg->msg_name) {
-		struct sockaddr_can *addr = msg->msg_name;
-		if (msg->msg_namelen < required_size(can_addr.j1939, *addr))
-			return -EFAULT;
-		if (addr->can_family != AF_CAN)
-			return -EINVAL;
-		if (ifindex && addr->can_ifindex &&
-			(ifindex != addr->can_ifindex))
-			return -ENONET;
-		if (!ifindex)
-			/* take destination intf when intf not yet set */
-			ifindex = addr->can_ifindex;
-	}
-
-	if (!ifindex)
-		return -EDESTADDRREQ;
-	if (j1939_no_address(&jsk->sk)) {
-		lock_sock(&jsk->sk);
-		ecu = j1939_ecu_find_segment_default_tx(
-				jsk->sk.sk_bound_dev_if,
-				&jsk->addr.src, &jsk->addr.sa);
-		release_sock(&jsk->sk);
-		if (IS_ERR(ecu))
-			return PTR_ERR(ecu);
-	}
-
-	dev = dev_get_by_index(&init_net, ifindex);
-	if (!dev)
-		return -ENXIO;
-
-	skb = sock_alloc_send_skb(sk, size,
-			msg->msg_flags & MSG_DONTWAIT, &ret);
-	if (!skb)
-		goto put_dev;
-
-	ret = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
-	if (ret < 0)
-		goto free_skb;
-	skb->dev = dev;
-	skb->sk  = sk;
-
-	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(*skb_cb));
-
-	skb_cb = (void *) skb->cb;
-	memset(skb_cb, 0, sizeof(*skb_cb));
-	skb_cb->msg_flags = msg->msg_flags;
-	skb_cb->ifindex = ifindex;
-	skb_cb->src.name = jsk->addr.src;
-	skb_cb->dst.name = jsk->addr.dst;
-	skb_cb->pgn = jsk->addr.pgn;
-	skb_cb->priority = j1939_prio(jsk->sk.sk_priority);
-	skb_cb->src.addr = jsk->addr.sa;
-	skb_cb->dst.addr = jsk->addr.da;
-
-	if (msg->msg_name) {
-		struct sockaddr_can *addr = msg->msg_name;
-		if (addr->can_addr.j1939.name) {
-			ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
-					ifindex);
-			if (!ecu)
-				return -EADDRNOTAVAIL;
-			skb_cb->dst.name = ecu->name;
-			skb_cb->dst.addr = ecu->sa;
-			put_j1939_ecu(ecu);
-		} else {
-			skb_cb->dst.name = 0;
-			skb_cb->dst.addr = addr->can_addr.j1939.addr;
-		}
-		if (pgn_is_valid(addr->can_addr.j1939.pgn))
-			skb_cb->pgn = addr->can_addr.j1939.pgn;
-	}
-
-	if (skb_cb->msg_flags & J1939_MSG_SYNC) {
-		if (skb_cb->msg_flags & MSG_DONTWAIT) {
-			ret = j1939_sock_pending_add_first(&jsk->sk);
-			if (ret > 0)
-				ret = -EAGAIN;
-		} else {
-			ret = wait_event_interruptible(jsk->waitq,
-					j1939_sock_pending_add_first(&jsk->sk));
-		}
-		if (ret < 0)
-			goto free_skb;
-	} else {
-		j1939_sock_pending_add(&jsk->sk);
-	}
-
-	ret = j1939_send(skb, j1939_level_sky);
-	if (ret < 0)
-		goto decrement_pending;
-
-	dev_put(dev);
-	return size;
-
-decrement_pending:
-	j1939_sock_pending_del(&jsk->sk);
-free_skb:
-	kfree_skb(skb);
-put_dev:
-	dev_put(dev);
-	return ret;
-}
-
-/* PROC */
-static int j1939sk_proc_show(struct seq_file *sqf, void *v)
-{
-	struct j1939_sock *jsk;
-	struct net_device *netdev;
-
-	seq_printf(sqf, "iface\tflags\tlocal\tremote\tpgn\tprio\tpending\n");
-	mutex_lock(&s.lock);
-	list_for_each_entry(jsk, &s.socks, list) {
-		lock_sock(&jsk->sk);
-		netdev = NULL;
-		if (jsk->sk.sk_bound_dev_if)
-			netdev = dev_get_by_index(&init_net,
-				jsk->sk.sk_bound_dev_if);
-		seq_printf(sqf, "%s\t", netdev ? netdev->name : "-");
-		if (netdev)
-			dev_put(netdev);
-		seq_printf(sqf, "%c%c%c%c\t",
-			(jsk->state & JSK_BOUND) ? 'b' : '-',
-			(jsk->state & JSK_CONNECTED) ? 'c' : '-',
-			(jsk->state & PROMISC) ? 'P' : '-',
-			(jsk->state & RECV_OWN) ? 'o' : '-');
-		if (jsk->addr.src)
-			seq_printf(sqf, "%016llx", (long long)jsk->addr.src);
-		else if (j1939_address_is_unicast(jsk->addr.sa))
-			seq_printf(sqf, "%02x", jsk->addr.sa);
-		else
-			seq_printf(sqf, "-");
-		seq_printf(sqf, "\t");
-		if (jsk->addr.dst)
-			seq_printf(sqf, "%016llx", (long long)jsk->addr.dst);
-		else if (j1939_address_is_unicast(jsk->addr.da))
-			seq_printf(sqf, "%02x", jsk->addr.da);
-		else
-			seq_printf(sqf, "-");
-		seq_printf(sqf, "\t%05x", jsk->addr.pgn);
-		seq_printf(sqf, "\t%u", j1939_prio(jsk->sk.sk_priority));
-		seq_printf(sqf, "\t%u", jsk->skb_pending);
-		release_sock(&jsk->sk);
-		seq_printf(sqf, "\n");
-	}
-	mutex_unlock(&s.lock);
-	return 0;
-}
-
-void j1939sk_netdev_event(int ifindex, int error_code)
-{
-	struct j1939_sock *jsk;
-
-	mutex_lock(&s.lock);
-	list_for_each_entry(jsk, &s.socks, list) {
-		if (jsk->sk.sk_bound_dev_if != ifindex)
-			continue;
-		jsk->sk.sk_err = error_code;
-		if (!sock_flag(&jsk->sk, SOCK_DEAD))
-			jsk->sk.sk_error_report(&jsk->sk);
-		/* do not remove filters here */
-	}
-	mutex_unlock(&s.lock);
-}
-
-static const struct proto_ops j1939_ops = {
-	.family = PF_CAN,
-	.release = j1939sk_release,
-	.bind = j1939sk_bind,
-	.connect = j1939sk_connect,
-	.socketpair = sock_no_socketpair,
-	.accept = sock_no_accept,
-	.getname = j1939sk_getname,
-	.poll = datagram_poll,
-	.ioctl = can_ioctl,
-	.listen = sock_no_listen,
-	.shutdown = sock_no_shutdown,
-	.setsockopt = j1939sk_setsockopt,
-	.getsockopt = j1939sk_getsockopt,
-	.sendmsg = j1939sk_sendmsg,
-	.recvmsg = j1939sk_recvmsg,
-	.mmap = sock_no_mmap,
-	.sendpage = sock_no_sendpage,
-};
-
-static struct proto j1939_proto __read_mostly = {
-	.name = "CAN_J1939",
-	.owner = THIS_MODULE,
-	.obj_size = sizeof(struct j1939_sock),
-	.init = j1939sk_init,
-};
-
-static const struct can_proto j1939_can_proto = {
-	.type = SOCK_DGRAM,
-	.protocol = CAN_J1939,
-	.ops = &j1939_ops,
-	.prot = &j1939_proto,
-
-	.rtnl_link_ops = &j1939_rtnl_af_ops,
-	.rtnl_new_addr = j1939rtnl_new_addr,
-	.rtnl_del_addr = j1939rtnl_del_addr,
-	.rtnl_dump_addr = j1939rtnl_dump_addr,
-};
-
-__init int j1939sk_module_init(void)
-{
-	int ret;
-
-	INIT_LIST_HEAD(&s.socks);
-	mutex_init(&s.lock);
-
-	ret = can_proto_register(&j1939_can_proto);
-	if (ret < 0)
-		pr_err("can: registration of j1939 protocol failed\n");
-	else
-		j1939_proc_add("sock", j1939sk_proc_show, NULL);
-	return ret;
-}
-
-void j1939sk_module_exit(void)
-{
-	j1939_proc_remove("sock");
-	can_proto_unregister(&j1939_can_proto);
-}
-
-MODULE_ALIAS("can-proto-" __stringify(CAN_J1939));
-
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/socket.h>
+#include <linux/list.h>
+#include <linux/if_arp.h>
+#include <net/tcp_states.h>
+
+#include <linux/can/core.h>
+#include <linux/can/j1939.h>
+#include "j1939-priv.h"
+
+//Transport protocol modification
+extern struct j1939_tp_mod tpmod;
+
+struct j1939_sock {
+	struct sock sk; /* must be first to skip with memset */
+	struct list_head list;
+
+	int state;
+	#define JSK_BOUND	BIT(0)
+	#define JSK_CONNECTED	BIT(1)
+	#define PROMISC		BIT(2)
+	#define RECV_OWN	BIT(3)
+	#define JSK_BAM_DELAY BIT(4)
+
+	struct {
+		name_t src, dst;
+		pgn_t pgn;
+
+		uint8_t sa, da;
+	} addr;
+
+	struct j1939_filter *filters;
+	int nfilters;
+
+	int skb_pending;
+	spinlock_t lock;
+	wait_queue_head_t waitq;
+};
+
+static inline struct j1939_sock *j1939_sk(const struct sock *sk)
+{
+	return container_of(sk, struct j1939_sock, sk);
+}
+
+/* skb_pending issues */
+static inline int j1939_sock_pending_add_first(struct sock *sk)
+{
+	int saved;
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	spin_lock_bh(&jsk->lock);
+	if (!jsk->skb_pending) {
+		++jsk->skb_pending;
+		saved = 1;
+	} else
+		saved = 0;
+	spin_unlock_bh(&jsk->lock);
+	return saved;
+}
+
+static inline void j1939_sock_pending_add(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	spin_lock_bh(&jsk->lock);
+	++jsk->skb_pending;
+	spin_unlock_bh(&jsk->lock);
+}
+
+void j1939_sock_pending_del(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int saved;
+
+	spin_lock_bh(&jsk->lock);
+	--jsk->skb_pending;
+	saved = jsk->skb_pending;
+	spin_unlock_bh(&jsk->lock);
+	if (!saved)
+		wake_up(&jsk->waitq);
+}
+
+
+static inline int j1939_no_address(const struct sock *sk)
+{
+	const struct j1939_sock *jsk = j1939_sk(sk);
+	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src;
+}
+
+/*
+ * list of sockets
+ */
+static struct {
+	struct mutex lock;
+	struct list_head socks;
+} s;
+
+/* matches skb control buffer (addr) with a j1939 filter */
+static inline int packet_match(const struct j1939_sk_buff_cb *cb,
+		const struct j1939_filter *f, int nfilter)
+{
+	if (!nfilter)
+		/* receive all when no filters are assigned */
+		return 1;
+	/*
+	 * Filters relying on the addr for static addressing _should_ get
+	 * packets from dynamic addressed ECU's too if they match their SA.
+	 * Sockets using dynamic addressing in their filters should not set it.
+	 */
+	for (; nfilter; ++f, --nfilter) {
+		if ((cb->pgn & f->pgn_mask) != (f->pgn & f->pgn_mask))
+			continue;
+		if ((cb->src.addr & f->addr_mask) != (f->addr & f->addr_mask))
+			continue;
+		if ((cb->src.name & f->name_mask) != (f->name & f->name_mask))
+			continue;
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * callback per socket, called from filter infrastructure
+ */
+static void j1939sk_recv_skb(struct sk_buff *oskb, void *data)
+{
+	struct sk_buff *skb;
+	struct j1939_sock *jsk = (struct j1939_sock *)data;
+	struct j1939_sk_buff_cb *cb = (void *)oskb->cb;
+
+	if (jsk->sk.sk_bound_dev_if && (jsk->sk.sk_bound_dev_if != cb->ifindex))
+		/* this socket does not take packets from this iface */
+		return;
+	if (!(jsk->state & PROMISC)) {
+		if (cb->dst.flags & ECUFLAG_REMOTE)
+			/*
+			 * this msg was destined for an ECU associated
+			 * with this socket
+			 */
+			return;
+		if (jsk->addr.src) {
+			if (cb->dst.name &&
+				(cb->dst.name != jsk->addr.src))
+				/*
+				 * the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		} else if (j1939_address_is_unicast(jsk->addr.sa)) {
+			if (j1939_address_is_unicast(cb->dst.addr) &&
+				(cb->dst.addr != jsk->addr.sa))
+				/*
+				 * the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		}
+	}
+
+	if ((oskb->sk == &jsk->sk) && !(jsk->state & RECV_OWN))
+		/* own message */
+		return;
+
+	if (!packet_match(cb, jsk->filters, jsk->nfilters))
+		return;
+
+	skb = skb_clone(oskb, GFP_ATOMIC);
+	if (!skb) {
+		j1939_warning("skb clone failed\n");
+		return;
+	}
+	cb = (void *)skb->cb;
+	cb->msg_flags &= ~(MSG_DONTROUTE | MSG_CONFIRM);
+	if (oskb->sk)
+		cb->msg_flags |= MSG_DONTROUTE;
+	if (oskb->sk == &jsk->sk)
+		cb->msg_flags |= MSG_CONFIRM;
+
+	skb->sk = &jsk->sk;
+	if (sock_queue_rcv_skb(&jsk->sk, skb) < 0)
+		kfree_skb(skb);
+}
+
+static int j1939sk_init(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	INIT_LIST_HEAD(&jsk->list);
+	spin_lock_init(&jsk->lock);
+	init_waitqueue_head(&jsk->waitq);
+	jsk->sk.sk_priority = j1939_to_sk_priority(6);
+	jsk->sk.sk_reuse = 1; /* per default */
+	jsk->addr.sa = J1939_NO_ADDR;
+	jsk->addr.da = J1939_NO_ADDR;
+	return 0;
+}
+
+/*
+ * helper: return <0 for error, >0 for error to notify
+ */
+static int j1939sk_bind_netdev_helper(struct socket *sock)
+{
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	int ret;
+	struct net_device *netdev;
+	struct j1939_segment *jseg;
+
+	if (!jsk->sk.sk_bound_dev_if)
+		return 0;
+	ret = 0;
+
+	netdev = dev_get_by_index(&init_net, jsk->sk.sk_bound_dev_if);
+	if (!netdev) {
+		ret = -ENODEV;
+		goto fail_netdev;
+	}
+
+	/* no need to test for CAN device,
+	 * implicitely done by j1939_segment
+	 */
+	jseg = j1939_segment_find(netdev->ifindex);
+	if (!jseg) {
+		ret = -EHOSTDOWN;
+		goto fail_segment;
+	}
+
+	if (!(netdev->flags & IFF_UP)) {
+		sock->sk->sk_err = ENETDOWN;
+		sock->sk->sk_error_report(sock->sk);
+	}
+	put_j1939_segment(jseg);
+fail_segment:
+	dev_put(netdev);
+fail_netdev:
+	return ret;
+}
+
+static int j1939sk_bind_addr_helper(int ifindex, uint8_t addr)
+{
+	struct j1939_segment *jseg;
+	struct addr_ent *paddr;
+	int flags;
+
+	/* static addressing, netdev is required */
+	if (!ifindex)
+		return -EINVAL;
+
+	jseg = j1939_segment_find(ifindex);
+	if (!jseg)
+		return -ENETUNREACH;
+	paddr = &jseg->ents[addr];
+	read_lock_bh(&jseg->lock);
+	flags = paddr->flags;
+	read_unlock_bh(&jseg->lock);
+	put_j1939_segment(jseg);
+	if (!(flags & ECUFLAG_LOCAL))
+		return -EADDRNOTAVAIL;
+	return 0;
+}
+
+static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	int ret, old_state;
+
+	if (len < required_size(can_addr.j1939, *addr))
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	/* lock s.lock first, to avoid circular lock dependancy */
+	mutex_lock(&s.lock);
+	lock_sock(sock->sk);
+	if (jsk->state & JSK_BOUND) {
+		ret = -EBUSY;
+		if (addr->can_ifindex &&
+				(addr->can_ifindex != jsk->sk.sk_bound_dev_if))
+			goto fail_locked;
+		if (jsk->addr.src &&
+				(jsk->addr.src == addr->can_addr.j1939.name)) {
+			/*
+			 * allow to change the address after the first bind()
+			 * when using dynamic addressing
+			 */
+			/* set to be able to send address claims */
+			jsk->addr.sa = addr->can_addr.j1939.addr;
+		} else if (jsk->addr.sa == addr->can_addr.j1939.addr) {
+			/* no change */
+		} else if (j1939_address_is_unicast(addr->can_addr.j1939.addr)) {
+			/* change of static source address */
+			ret = j1939sk_bind_addr_helper(jsk->sk.sk_bound_dev_if,
+					addr->can_addr.j1939.addr);
+			if (ret < 0)
+				goto fail_locked;
+			jsk->addr.sa = addr->can_addr.j1939.addr;
+		} else {
+			goto fail_locked;
+		}
+		/* set default transmit pgn */
+		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+		/* since this socket is bound already, we can skip a lot */
+		release_sock(sock->sk);
+		mutex_unlock(&s.lock);
+		return 0;
+	}
+
+	/* do netdev */
+	if (jsk->sk.sk_bound_dev_if && addr->can_ifindex &&
+			(jsk->sk.sk_bound_dev_if != addr->can_ifindex)) {
+		ret = -EBADR;
+		goto fail_locked;
+	}
+	if (!jsk->sk.sk_bound_dev_if)
+		jsk->sk.sk_bound_dev_if = addr->can_ifindex;
+
+	ret = j1939sk_bind_netdev_helper(sock);
+	if (ret < 0)
+		goto fail_locked;
+
+	/* bind name/addr */
+	if (addr->can_addr.j1939.name) {
+		struct j1939_ecu *ecu;
+
+		ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
+				jsk->sk.sk_bound_dev_if);
+		if (!ecu || IS_ERR(ecu)) {
+			ret = -EADDRNOTAVAIL;
+			goto fail_locked;
+		} else if (ecu->flags & ECUFLAG_REMOTE) {
+			ret = -EREMOTE;
+			put_j1939_ecu(ecu);
+			goto fail_locked;
+		} else if (jsk->sk.sk_bound_dev_if != ecu->parent->ifindex) {
+			ret = -EHOSTUNREACH;
+			put_j1939_ecu(ecu);
+			goto fail_locked;
+		}
+		jsk->addr.src = ecu->name;
+		jsk->addr.sa = addr->can_addr.j1939.addr;
+		put_j1939_ecu(ecu);
+	} else if (j1939_address_is_unicast(addr->can_addr.j1939.addr)) {
+		ret = j1939sk_bind_addr_helper(jsk->sk.sk_bound_dev_if,
+				addr->can_addr.j1939.addr);
+		if (ret < 0)
+			goto fail_locked;
+		jsk->addr.sa = addr->can_addr.j1939.addr;
+	} else if (addr->can_addr.j1939.addr == J1939_IDLE_ADDR) {
+		/* static addressing, netdev is required */
+		if (!jsk->sk.sk_bound_dev_if) {
+			ret = -EINVAL;
+			goto fail_locked;
+		}
+		jsk->addr.sa = addr->can_addr.j1939.addr;
+	} else {
+		/* no name, no addr */
+	}
+
+	/* set default transmit pgn */
+	jsk->addr.pgn = addr->can_addr.j1939.pgn;
+
+	old_state = jsk->state;
+	jsk->state |= JSK_BOUND;
+
+	if (!(old_state & (JSK_BOUND | JSK_CONNECTED))) {
+		list_add_tail(&jsk->list, &s.socks);
+		j1939_recv_add(jsk, j1939sk_recv_skb);
+	}
+
+	ret = 0;
+
+fail_locked:
+	release_sock(sock->sk);
+	mutex_unlock(&s.lock);
+	return ret;
+}
+
+static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
+		int len, int flags)
+{
+	int ret, old_state;
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	struct j1939_ecu *ecu;
+	int ifindex;
+
+	if (!uaddr)
+		return -EDESTADDRREQ;
+
+	if (len < required_size(can_addr.j1939, *addr))
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	mutex_lock(&s.lock);
+	lock_sock(sock->sk);
+	if (jsk->state & JSK_CONNECTED) {
+		ret = -EISCONN;
+		goto fail_locked;
+	}
+
+	ifindex = jsk->sk.sk_bound_dev_if;
+	if (ifindex && addr->can_ifindex && (ifindex != addr->can_ifindex)) {
+		ret = -ECONNREFUSED;
+		goto fail_locked;
+	}
+	if (!ifindex)
+		ifindex = addr->can_ifindex;
+
+	/* lookup destination */
+	if (addr->can_addr.j1939.name) {
+		ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
+				ifindex);
+		if (!ecu) {
+			ret = -EADDRNOTAVAIL;
+			goto fail_locked;
+		}
+		if (ifindex && (ifindex != ecu->parent->ifindex)) {
+			ret = -EHOSTUNREACH;
+			goto fail_locked;
+		}
+		ifindex = ecu->parent->ifindex;
+		jsk->addr.dst = ecu->name;
+		jsk->addr.da = ecu->sa;
+		put_j1939_ecu(ecu);
+	} else {
+		/* broadcast */
+		jsk->addr.dst = 0;
+		jsk->addr.da = addr->can_addr.j1939.addr;
+	}
+	/*
+	 * take a default source when not present, so connected sockets
+	 * will stick to the same source ECU
+	 */
+	if (!jsk->addr.src && !j1939_address_is_valid(jsk->addr.sa)) {
+		ecu = j1939_ecu_find_segment_default_tx(ifindex,
+				&jsk->addr.src, &jsk->addr.sa);
+		if (IS_ERR(ecu)) {
+			ret = PTR_ERR(ecu);
+			goto fail_locked;
+		}
+		put_j1939_ecu(ecu);
+	}
+
+	/* start assigning, no problem can occur at this point anymore */
+	jsk->sk.sk_bound_dev_if = ifindex;
+
+	if (!(jsk->state & JSK_BOUND) || !pgn_is_valid(jsk->addr.pgn)) {
+		/*
+		 * bind() takes precedence over connect() for the
+		 * pgn to use ourselve
+		 */
+		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+	}
+
+	old_state = jsk->state;
+	jsk->state |= JSK_CONNECTED;
+
+	if (!(old_state & (JSK_BOUND | JSK_CONNECTED))) {
+		list_add_tail(&jsk->list, &s.socks);
+		j1939_recv_add(jsk, j1939sk_recv_skb);
+	}
+	release_sock(sock->sk);
+	mutex_unlock(&s.lock);
+	return 0;
+
+fail_locked:
+	release_sock(sock->sk);
+	mutex_unlock(&s.lock);
+	return ret;
+}
+
+static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
+		const struct j1939_sock *jsk, int peer)
+{
+	addr->can_family = AF_CAN;
+	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
+	addr->can_addr.j1939.name = peer ? jsk->addr.dst : jsk->addr.src;
+	addr->can_addr.j1939.pgn = jsk->addr.pgn;
+	addr->can_addr.j1939.addr = peer ? jsk->addr.da : jsk->addr.sa;
+}
+
+static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
+		int *len, int peer)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret = 0;
+
+	lock_sock(sk);
+
+	if (peer && !(jsk->state & JSK_CONNECTED)) {
+		ret = -EADDRNOTAVAIL;
+		goto failure;
+	}
+
+	j1939sk_sock2sockaddr_can(addr, jsk, peer);
+	*len = sizeof(*addr);
+
+failure:
+	release_sock(sk);
+
+	return ret;
+}
+
+static int j1939sk_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk;
+
+	if (!sk)
+		return 0;
+	jsk = j1939_sk(sk);
+	j1939_recv_remove(jsk, j1939sk_recv_skb);
+	mutex_lock(&s.lock);
+	list_del_init(&jsk->list);
+	mutex_unlock(&s.lock);
+
+	lock_sock(sk);
+	if (jsk->state & PROMISC)
+		j1939_put_promisc_receiver(jsk->sk.sk_bound_dev_if);
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int j1939sk_setsockopt_flag(struct j1939_sock *jsk,
+		char __user *optval, unsigned int optlen, int flag)
+{
+	int tmp;
+
+	if (optlen != sizeof(tmp))
+		return -EINVAL;
+	if (copy_from_user(&tmp, optval, optlen))
+		return -EFAULT;
+	lock_sock(&jsk->sk);
+	if (tmp)
+		jsk->state |= flag;
+	else
+		jsk->state &= ~flag;
+	release_sock(&jsk->sk);
+	return tmp;
+}
+
+static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
+		char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret = 0, tmp, count;
+	struct j1939_filter *filters, *ofilters;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+
+	switch (optname) {
+	case SO_J1939_FILTER:
+		if (optval) {
+			if (optlen % sizeof(*filters) != 0)
+				return -EINVAL;
+			count = optlen / sizeof(*filters);
+			filters = kmalloc(optlen, GFP_KERNEL);
+			if (!filters)
+				return -ENOMEM;
+			if (copy_from_user(filters, optval, optlen)) {
+				kfree(filters);
+				return -EFAULT;
+			}
+		} else {
+			filters = NULL;
+			count = 0;
+		}
+
+		j1939_recv_suspend();
+		ofilters = jsk->filters;
+		jsk->filters = filters;
+		jsk->nfilters = count;
+		j1939_recv_resume();
+		if (ofilters)
+			kfree(ofilters);
+		break;
+	case SO_J1939_PROMISC:
+		tmp = jsk->state & PROMISC;
+		ret = j1939sk_setsockopt_flag(jsk, optval, optlen, PROMISC);
+		if (ret && !tmp)
+			j1939_get_promisc_receiver(jsk->sk.sk_bound_dev_if);
+		else if (!ret && tmp)
+			j1939_put_promisc_receiver(jsk->sk.sk_bound_dev_if);
+		ret = 0;
+		break;
+	case SO_J1939_RECV_OWN:
+		j1939sk_setsockopt_flag(jsk, optval, optlen, RECV_OWN);
+		break;
+	case SO_J1939_SEND_PRIO:
+		if (optlen != sizeof(tmp))
+			return -EINVAL;
+		if (copy_from_user(&tmp, optval, optlen))
+			return -EFAULT;
+		if ((tmp < 0) || (tmp > 7))
+			return -EDOM;
+		if ((tmp < 2) && !capable(CAP_NET_ADMIN))
+			return -EPERM;
+		lock_sock(&jsk->sk);
+		jsk->sk.sk_priority = j1939_to_sk_priority(tmp);
+		release_sock(&jsk->sk);
+		break;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		//Enables/Disables delay
+		tmp = j1939sk_setsockopt_flag(jsk, optval, optlen, JSK_BAM_DELAY);
+		printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+		printk("DEBUG: SO_J1939_BAM_DELAY_DISABLE used with value: %d\n",tmp);
+		printk("DEBUG: jsk->state: %d\n",(int)(jsk->state));
+		return tmp;
+	default:
+		return -ENOPROTOOPT;
+	}
+
+	return ret;
+}
+
+static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
+		char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret, ulen;
+	/* set defaults for using 'int' properties */
+	int tmp = 0;
+	int len = sizeof(tmp);
+	void *val = &tmp;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+	if (get_user(ulen, optlen))
+		return -EFAULT;
+	if (ulen < 0)
+		return -EINVAL;
+
+	lock_sock(&jsk->sk);
+	switch (optname) {
+	case SO_J1939_PROMISC:
+		tmp = (jsk->state & PROMISC) ? 1 : 0;
+		break;
+	case SO_J1939_RECV_OWN:
+		tmp = (jsk->state & RECV_OWN) ? 1 : 0;
+		break;
+	case SO_J1939_SEND_PRIO:
+		tmp = j1939_prio(jsk->sk.sk_priority);
+		break;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		tmp = (jsk->state & JSK_BAM_DELAY) ? 1 : 0;
+		break;
+	default:
+		ret = -ENOPROTOOPT;
+		goto no_copy;
+	}
+
+	/*
+	 * copy to user, based on 'len' & 'val'
+	 * but most sockopt's are 'int' properties, and have 'len' & 'val'
+	 * left unchanged, but instead modified 'tmp'
+	 */
+	if (len > ulen)
+		ret = -EFAULT;
+	else if (put_user(len, optlen))
+		ret = -EFAULT;
+	else if (copy_to_user(optval, val, len))
+		ret = -EFAULT;
+	else
+		ret = 0;
+no_copy:
+	release_sock(&jsk->sk);
+	return ret;
+}
+
+static int j1939sk_recvmsg(struct kiocb *iocb, struct socket *sock,
+			 struct msghdr *msg, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *sk_addr;
+	int ret = 0;
+
+	skb = skb_recv_datagram(sk, flags, 0, &ret);
+	if (!skb)
+		return ret;
+
+	if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+	else
+		size = skb->len;
+
+	ret = memcpy_toiovec(msg->msg_iov, skb->data, size);
+	if (ret < 0)
+		goto failed_with_skb;
+
+	sock_recv_timestamp(msg, sk, skb);
+	sk_addr = (void *)skb->cb;
+
+	if (j1939_address_is_valid(sk_addr->dst.addr))
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
+				sizeof(sk_addr->dst.addr), &sk_addr->dst.addr);
+
+	if (sk_addr->dst.name)
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,
+				sizeof(sk_addr->dst.name), &sk_addr->dst.name);
+
+	put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,
+			sizeof(sk_addr->priority), &sk_addr->priority);
+
+	if (msg->msg_name) {
+		struct sockaddr_can *paddr = msg->msg_name;
+
+		msg->msg_namelen = required_size(can_addr.j1939, *paddr);
+		memset(msg->msg_name, 0, msg->msg_namelen);
+		paddr->can_family = AF_CAN;
+		paddr->can_ifindex = sk_addr->ifindex;
+		paddr->can_addr.j1939.name = sk_addr->src.name;
+		paddr->can_addr.j1939.addr = sk_addr->src.addr;
+		paddr->can_addr.j1939.pgn = sk_addr->pgn;
+	}
+
+	msg->msg_flags |= sk_addr->msg_flags;
+	skb_free_datagram(sk, skb);
+
+	return size;
+
+failed_with_skb:
+	skb_kill_datagram(sk, skb, flags);
+	return ret;
+}
+
+static int j1939sk_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	struct j1939_sk_buff_cb *skb_cb;
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct j1939_ecu *ecu;
+	int ifindex;
+	int ret;
+
+	if (!(jsk->state & JSK_BOUND))
+		return -ENOTCONN;
+
+	if (msg->msg_name && (msg->msg_namelen <
+			required_size(can_addr.j1939, struct sockaddr_can)))
+		return -EINVAL;
+
+	ifindex = jsk->sk.sk_bound_dev_if;
+	if (msg->msg_name) {
+		struct sockaddr_can *addr = msg->msg_name;
+		if (msg->msg_namelen < required_size(can_addr.j1939, *addr))
+			return -EFAULT;
+		if (addr->can_family != AF_CAN)
+			return -EINVAL;
+		if (ifindex && addr->can_ifindex &&
+			(ifindex != addr->can_ifindex))
+			return -ENONET;
+		if (!ifindex)
+			/* take destination intf when intf not yet set */
+			ifindex = addr->can_ifindex;
+	}
+
+	if (!ifindex)
+		return -EDESTADDRREQ;
+	if (j1939_no_address(&jsk->sk)) {
+		lock_sock(&jsk->sk);
+		ecu = j1939_ecu_find_segment_default_tx(
+				jsk->sk.sk_bound_dev_if,
+				&jsk->addr.src, &jsk->addr.sa);
+		release_sock(&jsk->sk);
+		if (IS_ERR(ecu))
+			return PTR_ERR(ecu);
+	}
+
+	dev = dev_get_by_index(&init_net, ifindex);
+	if (!dev)
+		return -ENXIO;
+
+	skb = sock_alloc_send_skb(sk, size,
+			msg->msg_flags & MSG_DONTWAIT, &ret);
+	if (!skb)
+		goto put_dev;
+
+	ret = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+	if (ret < 0)
+		goto free_skb;
+	skb->dev = dev;
+	skb->sk  = sk;
+
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(*skb_cb));
+
+	skb_cb = (void *) skb->cb;
+	memset(skb_cb, 0, sizeof(*skb_cb));
+	skb_cb->msg_flags = msg->msg_flags;
+	skb_cb->ifindex = ifindex;
+	skb_cb->src.name = jsk->addr.src;
+	skb_cb->dst.name = jsk->addr.dst;
+	skb_cb->pgn = jsk->addr.pgn;
+	skb_cb->priority = j1939_prio(jsk->sk.sk_priority);
+	skb_cb->src.addr = jsk->addr.sa;
+	skb_cb->dst.addr = jsk->addr.da;
+
+	//Check if delay has been disabled
+	tpmod.tpflags = (jsk->state & JSK_BAM_DELAY)?BAM_NODELAY:0;
+	printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	printk("DEBUG: sk_cb->tpflags state: %d\n",tpmod.tpflags);
+
+
+	if (msg->msg_name) {
+		struct sockaddr_can *addr = msg->msg_name;
+		if (addr->can_addr.j1939.name) {
+			ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
+					ifindex);
+			if (!ecu)
+				return -EADDRNOTAVAIL;
+			skb_cb->dst.name = ecu->name;
+			skb_cb->dst.addr = ecu->sa;
+			put_j1939_ecu(ecu);
+		} else {
+			skb_cb->dst.name = 0;
+			skb_cb->dst.addr = addr->can_addr.j1939.addr;
+		}
+		if (pgn_is_valid(addr->can_addr.j1939.pgn))
+			skb_cb->pgn = addr->can_addr.j1939.pgn;
+	}
+
+	if (skb_cb->msg_flags & J1939_MSG_SYNC) {
+		if (skb_cb->msg_flags & MSG_DONTWAIT) {
+			ret = j1939_sock_pending_add_first(&jsk->sk);
+			if (ret > 0)
+				ret = -EAGAIN;
+		} else {
+			ret = wait_event_interruptible(jsk->waitq,
+					j1939_sock_pending_add_first(&jsk->sk));
+		}
+		if (ret < 0)
+			goto free_skb;
+	} else {
+		j1939_sock_pending_add(&jsk->sk);
+	}
+
+	ret = j1939_send(skb, j1939_level_sky);
+	if (ret < 0)
+		goto decrement_pending;
+
+	dev_put(dev);
+	return size;
+
+decrement_pending:
+	j1939_sock_pending_del(&jsk->sk);
+free_skb:
+	kfree_skb(skb);
+put_dev:
+	dev_put(dev);
+	return ret;
+}
+
+/* PROC */
+static int j1939sk_proc_show(struct seq_file *sqf, void *v)
+{
+	struct j1939_sock *jsk;
+	struct net_device *netdev;
+
+	seq_printf(sqf, "iface\tflags\tlocal\tremote\tpgn\tprio\tpending\n");
+	mutex_lock(&s.lock);
+	list_for_each_entry(jsk, &s.socks, list) {
+		lock_sock(&jsk->sk);
+		netdev = NULL;
+		if (jsk->sk.sk_bound_dev_if)
+			netdev = dev_get_by_index(&init_net,
+				jsk->sk.sk_bound_dev_if);
+		seq_printf(sqf, "%s\t", netdev ? netdev->name : "-");
+		if (netdev)
+			dev_put(netdev);
+		seq_printf(sqf, "%c%c%c%c\t",
+			(jsk->state & JSK_BOUND) ? 'b' : '-',
+			(jsk->state & JSK_CONNECTED) ? 'c' : '-',
+			(jsk->state & PROMISC) ? 'P' : '-',
+			(jsk->state & RECV_OWN) ? 'o' : '-');
+		if (jsk->addr.src)
+			seq_printf(sqf, "%016llx", (long long)jsk->addr.src);
+		else if (j1939_address_is_unicast(jsk->addr.sa))
+			seq_printf(sqf, "%02x", jsk->addr.sa);
+		else
+			seq_printf(sqf, "-");
+		seq_printf(sqf, "\t");
+		if (jsk->addr.dst)
+			seq_printf(sqf, "%016llx", (long long)jsk->addr.dst);
+		else if (j1939_address_is_unicast(jsk->addr.da))
+			seq_printf(sqf, "%02x", jsk->addr.da);
+		else
+			seq_printf(sqf, "-");
+		seq_printf(sqf, "\t%05x", jsk->addr.pgn);
+		seq_printf(sqf, "\t%u", j1939_prio(jsk->sk.sk_priority));
+		seq_printf(sqf, "\t%u", jsk->skb_pending);
+		release_sock(&jsk->sk);
+		seq_printf(sqf, "\n");
+	}
+	mutex_unlock(&s.lock);
+	return 0;
+}
+
+void j1939sk_netdev_event(int ifindex, int error_code)
+{
+	struct j1939_sock *jsk;
+
+	mutex_lock(&s.lock);
+	list_for_each_entry(jsk, &s.socks, list) {
+		if (jsk->sk.sk_bound_dev_if != ifindex)
+			continue;
+		jsk->sk.sk_err = error_code;
+		if (!sock_flag(&jsk->sk, SOCK_DEAD))
+			jsk->sk.sk_error_report(&jsk->sk);
+		/* do not remove filters here */
+	}
+	mutex_unlock(&s.lock);
+}
+
+static const struct proto_ops j1939_ops = {
+	.family = PF_CAN,
+	.release = j1939sk_release,
+	.bind = j1939sk_bind,
+	.connect = j1939sk_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = j1939sk_getname,
+	.poll = datagram_poll,
+	.ioctl = can_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = j1939sk_setsockopt,
+	.getsockopt = j1939sk_getsockopt,
+	.sendmsg = j1939sk_sendmsg,
+	.recvmsg = j1939sk_recvmsg,
+	.mmap = sock_no_mmap,
+	.sendpage = sock_no_sendpage,
+};
+
+static struct proto j1939_proto __read_mostly = {
+	.name = "CAN_J1939",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct j1939_sock),
+	.init = j1939sk_init,
+};
+
+static const struct can_proto j1939_can_proto = {
+	.type = SOCK_DGRAM,
+	.protocol = CAN_J1939,
+	.ops = &j1939_ops,
+	.prot = &j1939_proto,
+
+	.rtnl_link_ops = &j1939_rtnl_af_ops,
+	.rtnl_new_addr = j1939rtnl_new_addr,
+	.rtnl_del_addr = j1939rtnl_del_addr,
+	.rtnl_dump_addr = j1939rtnl_dump_addr,
+};
+
+__init int j1939sk_module_init(void)
+{
+	int ret;
+
+	INIT_LIST_HEAD(&s.socks);
+	mutex_init(&s.lock);
+
+	ret = can_proto_register(&j1939_can_proto);
+	if (ret < 0)
+		pr_err("can: registration of j1939 protocol failed\n");
+	else
+		j1939_proc_add("sock", j1939sk_proc_show, NULL);
+	return ret;
+}
+
+void j1939sk_module_exit(void)
+{
+	j1939_proc_remove("sock");
+	can_proto_unregister(&j1939_can_proto);
+}
+
+MODULE_ALIAS("can-proto-" __stringify(CAN_J1939));
+
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 9f723c6..6977f0b 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -1,1449 +1,1495 @@
-/*
- * Copyright (c) 2010-2011 EIA Electronics
- *
- * Authors:
- * Kurt Van Dijck <kurt.van.dijck@eia.be>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the version 2 of the GNU General Public License
- * as published by the Free Software Foundation
- */
-
-#include <linux/skbuff.h>
-#include <linux/hrtimer.h>
-#include <linux/version.h>
-#include <linux/if_arp.h>
-#include <linux/wait.h>
-#include "j1939-priv.h"
-
-#define REGULAR		0
-#define EXTENDED	1
-
-#define etp_pgn_ctl	0xc800
-#define etp_pgn_dat	0xc700
-#define tp_pgn_ctl	0xec00
-#define tp_pgn_dat	0xeb00
-
-#define  tp_cmd_bam	0x20
-#define  tp_cmd_rts	0x10
-#define  tp_cmd_cts	0x11
-#define  tp_cmd_eof	0x13
-#define  tp_cmd_abort	0xff
-
-#define etp_cmd_rts	0x14
-#define etp_cmd_cts	0x15
-#define etp_cmd_dpo	0x16
-#define etp_cmd_eof	0x17
-#define etp_cmd_abort	0xff
-
-#define ABORT_BUSY	1
-#define ABORT_RESOURCE	2
-#define ABORT_TIMEOUT	3
-#define ABORT_GENERIC	4
-#define ABORT_FAULT	5
-
-#define MAX_TP_PACKET_SIZE	(7*255)
-#define MAX_ETP_PACKET_SIZE	(7*0xffffff)
-
-static int block = 255;
-static int max_packet_size = 1024*100;
-static int retry_ms = 20;
-
-struct session {
-	struct list_head list;
-	atomic_t refs;
-	spinlock_t lock;
-
-	struct j1939_sk_buff_cb *cb; /*
-	 * ifindex, src, dst, pgn define the session block
-	 * the are _never_ modified after insertion in the list
-	 * this decreases locking problems a _lot_
-	 */
-	struct sk_buff *skb;
-
-	/*
-	 * all tx related stuff (last_txcmd, pkt.tx)
-	 * is protected (modified only) with the txtask tasklet
-	 * 'total' & 'block' are never changed,
-	 * last_cmd, last & block are protected by ->lock
-	 * this means that the tx may run after cts is received that should
-	 * have stopped tx, but this time discrepancy is never avoided anyhow
-	 */
-	uint8_t last_cmd, last_txcmd;
-	uint8_t transmission;
-	uint8_t extd;
-	struct {
-		/*
-		 * these do not require 16 bit, they should fit in uint8_t
-		 * but putting in int makes it easier to deal with
-		 */
-		unsigned int total, done, last, tx;
-		unsigned int block; /* for TP */
-		unsigned int dpo; /* for ETP */
-	} pkt;
-	struct hrtimer txtimer, rxtimer;
-	/* tasklets for execution of tx/rx timer hander in softirq */
-	struct tasklet_struct txtask, rxtask;
-};
-
-static struct j1939tp {
-	spinlock_t lock;
-	struct list_head sessionq;
-	struct list_head extsessionq;
-	struct {
-		struct list_head sessionq;
-		spinlock_t lock;
-		struct work_struct work;
-	} del;
-	wait_queue_head_t wait;
-	struct notifier_block notifier;
-} s;
-
-static struct session *j1939session_new(struct sk_buff *skb);
-static struct session *j1939session_fresh_new(int size,
-		struct j1939_sk_buff_cb *rel_cb, pgn_t pgn);
-
-static inline void fix_cb(struct j1939_sk_buff_cb *cb)
-{
-	cb->msg_flags &= ~J1939_MSG_RESERVED;
-}
-
-static inline struct list_head *sessionq(int extd)
-{
-	return extd ? &s.extsessionq : &s.sessionq;
-}
-
-static inline void j1939session_destroy(struct session *session)
-{
-	if (session->skb)
-		kfree_skb(session->skb);
-	hrtimer_cancel(&session->rxtimer);
-	hrtimer_cancel(&session->txtimer);
-	tasklet_disable(&session->rxtask);
-	tasklet_disable(&session->txtask);
-	kfree(session);
-}
-
-/* clean up work queue */
-static void j1939tp_del_work(struct work_struct *work)
-{
-	struct session *session;
-	int cnt = 0;
-
-	do {
-		session = NULL;
-		spin_lock_bh(&s.del.lock);
-		if (list_empty(&s.del.sessionq)) {
-			spin_unlock_bh(&s.del.lock);
-			break;
-		}
-		session = list_first_entry(&s.del.sessionq,
-				struct session, list);
-		list_del_init(&session->list);
-		spin_unlock_bh(&s.del.lock);
-		j1939session_destroy(session);
-		++cnt;
-	} while (1);
-}
-/* reference counter */
-static inline void get_session(struct session *session)
-{
-	atomic_inc(&session->refs);
-}
-
-static void put_session(struct session *session)
-{
-	BUG_ON(!session);
-	if (atomic_add_return(-1, &session->refs) >= 0)
-		/* not the last one */
-		return;
-	/* it should have been removed from any list long time ago */
-	BUG_ON(!list_empty(&session->list));
-
-	hrtimer_try_to_cancel(&session->rxtimer);
-	hrtimer_try_to_cancel(&session->txtimer);
-	tasklet_disable_nosync(&session->rxtask);
-	tasklet_disable_nosync(&session->txtask);
-
-	if (in_interrupt()) {
-		spin_lock_bh(&s.del.lock);
-		list_add_tail(&session->list, &s.del.sessionq);
-		spin_unlock_bh(&s.del.lock);
-		schedule_work(&s.del.work);
-	} else {
-		/* destroy session right here */
-		j1939session_destroy(session);
-	}
-}
-
-/* transport status locking */
-static inline void session_lock(struct session *session)
-{
-	get_session(session); /* safety measure */
-	spin_lock_bh(&session->lock);
-}
-
-static inline void session_unlock(struct session *session)
-{
-	spin_unlock_bh(&session->lock);
-	put_session(session);
-}
-
-static inline void sessionlist_lock(void)
-{
-	spin_lock_bh(&s.lock);
-}
-
-static inline void sessionlist_unlock(void)
-{
-	spin_unlock_bh(&s.lock);
-}
-
-/*
- * see if we are receiver
- * returns 0 for broadcasts, although we will receive them
- */
-static inline int j1939tp_im_receiver(const struct j1939_sk_buff_cb *cb)
-{
-	return (cb->dst.flags & ECUFLAG_LOCAL) ? 1 : 0;
-}
-
-/* see if we are sender */
-static inline int j1939tp_im_transmitter(const struct j1939_sk_buff_cb *cb)
-{
-	return (cb->src.flags & ECUFLAG_LOCAL) ? 1 : 0;
-}
-
-/* see if we are involved as either receiver or transmitter */
-/* reverse = -1 means : any direction */
-static int j1939tp_im_involved(const struct j1939_sk_buff_cb *cb, int reverse)
-{
-	if (reverse < 0) {
-		return ((cb->src.flags | cb->dst.flags) & ECUFLAG_LOCAL)
-			? 1 : 0;
-	} else if (reverse) {
-		return j1939tp_im_receiver(cb);
-	} else {
-		return j1939tp_im_transmitter(cb);
-	}
-}
-
-/* extract pgn from flow-ctl message */
-static inline pgn_t j1939xtp_ctl_to_pgn(const uint8_t *dat)
-{
-	pgn_t pgn;
-
-	pgn = (dat[7] << 16) | (dat[6] << 8) | (dat[5] << 0);
-	if (pgn_is_pdu1(pgn))
-		pgn &= 0xffff00;
-	return pgn;
-}
-
-static inline unsigned int j1939tp_ctl_to_size(const uint8_t *dat)
-{
-	return (dat[2] << 8) + (dat[1] << 0);
-}
-static inline unsigned int j1939etp_ctl_to_packet(const uint8_t *dat)
-{
-	return (dat[4] << 16) | (dat[3] << 8) | (dat[2] << 0);
-}
-static inline unsigned int j1939etp_ctl_to_size(const uint8_t *dat)
-{
-	return (dat[4] << 24) | (dat[3] << 16) |
-		(dat[2] << 8) | (dat[1] << 0);
-}
-
-/*
- * find existing session:
- * reverse: swap cb's src & dst
- * there is no problem with matching broadcasts, since
- * broadcasts (no dst, no da) would never call this
- * with reverse==1
- */
-static int j1939tp_match(const struct j1939_sk_buff_cb *a,
-		const struct j1939_sk_buff_cb *b, int reverse)
-{
-	if (a->ifindex != b->ifindex)
-		return 0;
-	if (!reverse) {
-		if (a->src.name) {
-			if (a->src.name != b->src.name)
-				return 0;
-		} else if (a->src.addr != b->src.addr)
-			return 0;
-		if (a->dst.name) {
-			if (a->dst.name != b->dst.name)
-				return 0;
-		} else if (a->dst.addr != b->dst.addr)
-			return 0;
-	} else {
-		if (a->src.name) {
-			if (a->src.name != b->dst.name)
-				return 0;
-		} else if (a->src.addr != b->dst.addr)
-			return 0;
-		if (a->dst.name) {
-			if (a->dst.name != b->src.name)
-				return 0;
-		} else if (a->dst.addr != b->src.addr)
-			return 0;
-	}
-	return 1;
-}
-
-static struct session *_j1939tp_find(struct list_head *root,
-		const struct j1939_sk_buff_cb *cb, int reverse)
-{
-	struct session *session;
-
-	list_for_each_entry(session, root, list) {
-		get_session(session);
-		if (j1939tp_match(session->cb, cb, reverse))
-			return session;
-		put_session(session);
-	}
-	return NULL;
-}
-
-static struct session *j1939tp_find(struct list_head *root,
-		const struct j1939_sk_buff_cb *cb, int reverse)
-{
-	struct session *session;
-	sessionlist_lock();
-	session = _j1939tp_find(root, cb, reverse);
-	sessionlist_unlock();
-	return session;
-}
-
-static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
-{
-	name_t name;
-	uint8_t addr;
-	int flags;
-
-	name = cb->dst.name;
-	cb->dst.name = cb->src.name;
-	cb->src.name = name;
-
-	addr = cb->dst.addr;
-	cb->dst.addr = cb->src.addr;
-	cb->src.addr = addr;
-
-	flags = cb->dst.flags;
-	cb->dst.flags = cb->src.flags;
-	cb->src.flags = flags;
-}
-/* TP transmit packet functions */
-static int j1939tp_tx_dat(struct session *related,
-		const uint8_t *dat, int len)
-{
-	int ret;
-	struct sk_buff *skb;
-	struct j1939_sk_buff_cb *skb_cb;
-	uint8_t *skdat;
-
-	skb = dev_alloc_skb(8);
-	if (unlikely(!skb)) {
-		pr_alert("%s: out of memory?\n", __func__);
-		return -ENOMEM;
-	}
-	skb->protocol = related->skb->protocol;
-	skb->pkt_type = related->skb->pkt_type;
-	skb->ip_summed = related->skb->ip_summed;
-	skb->sk	= related->skb->sk;
-
-	skb_cb = (void *)skb->cb;
-	*skb_cb = *(related->cb);
-	fix_cb(skb_cb);
-	/* fix pgn */
-	skb_cb->pgn = related->extd ? etp_pgn_dat : tp_pgn_dat;
-
-	skdat = skb_put(skb, len);
-	memcpy(skdat, dat, len);
-	ret = j1939_send(skb, j1939_level_transport);
-	if (ret < 0)
-		kfree_skb(skb);
-	return ret;
-}
-
-static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
-		int swap_src_dst, pgn_t pgn, const uint8_t dat[5])
-{
-	int ret;
-	struct sk_buff *skb;
-	struct j1939_sk_buff_cb *skb_cb, *rel_cb;
-	uint8_t *skdat;
-
-	rel_cb = (void *)related->cb;
-	if (!j1939tp_im_involved(rel_cb, swap_src_dst))
-		return 0;
-
-	skb = dev_alloc_skb(8);
-	if (unlikely(!skb)) {
-		pr_alert("%s: out of memory?\n", __func__);
-		return -ENOMEM;
-	}
-	skb->protocol = related->protocol;
-	skb->pkt_type = related->pkt_type;
-	skb->ip_summed = related->ip_summed;
-	skb->sk	= related->sk;
-
-	skb_cb = (void *)skb->cb;
-	*skb_cb = *rel_cb;
-	fix_cb(skb_cb);
-	if (swap_src_dst)
-		j1939_skbcb_swap(skb_cb);
-	skb_cb->pgn = extd ? etp_pgn_ctl : tp_pgn_ctl;
-
-	skdat = skb_put(skb, 8);
-	memcpy(skdat, dat, 5);
-	skdat[7] = (pgn >> 16) & 0xff;
-	skdat[6] = (pgn >>  8) & 0xff;
-	skdat[5] = (pgn >>  0) & 0xff;
-
-	ret = j1939_send(skb, j1939_level_transport);
-	if (ret)
-		kfree_skb(skb);
-	return ret;
-}
-
-static inline int j1939tp_tx_ctl(struct session *session,
-		int swap_src_dst, const uint8_t dat[8])
-{
-	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
-			session->cb->pgn, dat);
-}
-
-static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
-		int swap_src_dst, int err, pgn_t pgn)
-{
-	struct j1939_sk_buff_cb *cb = (void *)related->cb;
-	uint8_t dat[5];
-
-	if (!j1939tp_im_involved(cb, swap_src_dst))
-		return 0;
-
-	memset(dat, 0xff, sizeof(dat));
-	dat[0] = tp_cmd_abort;
-	if (!extd)
-		dat[1] = err ?: ABORT_GENERIC;
-	return j1939xtp_do_tx_ctl(related, extd, swap_src_dst, pgn, dat);
-}
-
-/* timer & scheduler functions */
-static inline void j1939session_schedule_txnow(struct session *session)
-{
-	tasklet_schedule(&session->txtask);
-}
-static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
-{
-	struct session *session =
-		container_of(hrtimer, struct session, txtimer);
-	j1939session_schedule_txnow(session);
-	return HRTIMER_NORESTART;
-}
-static inline void j1939tp_schedule_txtimer(struct session *session, int msec)
-{
-	hrtimer_start(&session->txtimer,
-			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
-			HRTIMER_MODE_REL);
-}
-static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
-{
-	hrtimer_start(&session->rxtimer,
-			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
-			HRTIMER_MODE_REL);
-}
-
-/*
- * session completion functions
- */
-/*
- * j1939session_drop
- * removes a session from open session list
- */
-static inline void j1939session_drop(struct session *session)
-{
-	sessionlist_lock();
-	list_del_init(&session->list);
-	sessionlist_unlock();
-
-	if (session->transmission) {
-		if (session->skb && session->skb->sk)
-			j1939_sock_pending_del(session->skb->sk);
-		wake_up_all(&s.wait);
-	}
-	put_session(session);
-}
-
-static inline void j1939session_completed(struct session *session)
-{
-	j1939_recv(session->skb, j1939_level_transport);
-	j1939session_drop(session);
-}
-
-static void j1939session_cancel(struct session *session, int err)
-{
-	if ((err >= 0) && j1939tp_im_involved(session->cb, -1)) {
-		if (!j1939cb_is_broadcast(session->cb)) {
-			/* do not send aborts on incoming broadcasts */
-			j1939xtp_tx_abort(session->skb, session->extd,
-				!j1939tp_im_transmitter(session->cb),
-				err, session->cb->pgn);
-		}
-	}
-	j1939session_drop(session);
-}
-
-static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
-{
-	struct session *session =
-		container_of(hrtimer, struct session, rxtimer);
-	tasklet_schedule(&session->rxtask);
-	return HRTIMER_NORESTART;
-}
-
-static void j1939tp_rxtask(unsigned long val)
-{
-	struct session *session = (void *)val;
-
-	get_session(session);
-	pr_alert("%s: timeout on %i\n", __func__, session->cb->ifindex);
-	j1939session_cancel(session, ABORT_TIMEOUT);
-	put_session(session);
-}
-
-/*
- * receive packet functions
- */
-static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	pgn_t pgn;
-
-	pgn = j1939xtp_ctl_to_pgn(skb->data);
-	session = j1939tp_find(sessionq(extd), cb, 0);
-	if (session /*&& (session->cb->pgn == pgn)*/) {
-		/* do not allow TP control messages on 2 pgn's */
-		j1939session_cancel(session, ABORT_FAULT);
-		put_session(session); /* ~j1939tp_find */
-		return;
-	}
-	j1939xtp_tx_abort(skb, extd, 0, ABORT_FAULT, pgn);
-	if (!session)
-		return;
-	put_session(session); /* ~j1939tp_find */
-}
-
-/* abort packets may come in 2 directions */
-static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-
-	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
-	_j1939xtp_rx_bad_message(skb, extd);
-	j1939_skbcb_swap(cb);
-	_j1939xtp_rx_bad_message(skb, extd);
-	/* restore skb */
-	j1939_skbcb_swap(cb);
-	return;
-}
-
-static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	pgn_t pgn;
-
-	pgn = j1939xtp_ctl_to_pgn(skb->data);
-	session = j1939tp_find(sessionq(extd), cb, 0);
-	if (!session)
-		return;
-	if (session->transmission && !session->last_txcmd) {
-		/*
-		 * empty block:
-		 * do not drop session when a transmit session did not
-		 * start yet
-		 */
-	} else if (session->cb->pgn == pgn)
-		j1939session_drop(session);
-	/* another PGN had a bad message */
-	/*
-	 * TODO: maybe cancel current connection
-	 * as another pgn was communicated
-	 */
-	put_session(session); /* ~j1939tp_find */
-}
-/* abort packets may come in 2 directions */
-static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-
-	pr_info("%s %i, %05x\n", __func__, cb->ifindex,
-			j1939xtp_ctl_to_pgn(skb->data));
-	_j1939xtp_rx_abort(skb, extd);
-	j1939_skbcb_swap(cb);
-	_j1939xtp_rx_abort(skb, extd);
-	/* restore skb */
-	j1939_skbcb_swap(cb);
-	return;
-}
-
-static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	pgn_t pgn;
-
-	/* end of tx cycle */
-	pgn = j1939xtp_ctl_to_pgn(skb->data);
-	session = j1939tp_find(sessionq(extd), cb, 1);
-	if (!session)
-		/*
-		 * strange, we had EOF on closed connection
-		 * do nothing, as EOF closes the connection anyway
-		 */
-		return;
-
-	if (session->cb->pgn != pgn) {
-		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
-		j1939session_cancel(session, ABORT_BUSY);
-	} else {
-		/* transmitted without problems */
-		j1939session_completed(session);
-	}
-	put_session(session); /* ~j1939tp_find */
-}
-
-static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	pgn_t pgn;
-	unsigned int pkt;
-	const uint8_t *dat;
-
-	dat = skb->data;
-	pgn = j1939xtp_ctl_to_pgn(skb->data);
-	session = j1939tp_find(sessionq(extd), cb, 1);
-	if (!session) {
-		/* 'CTS shall be ignored' */
-		return;
-	}
-	if (session->cb->pgn != pgn) {
-		/* what to do? */
-		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
-		j1939session_cancel(session, ABORT_BUSY);
-		put_session(session); /* ~j1939tp_find */
-		return;
-	}
-	session_lock(session);
-	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
-	if (!dat[0])
-		hrtimer_cancel(&session->txtimer);
-	else if (!pkt)
-		goto bad_fmt;
-	else if (dat[1] > session->pkt.block /* 0xff for etp */)
-		goto bad_fmt;
-	else {
-		/* set packet counters only when not CTS(0) */
-		session->pkt.done = pkt - 1;
-		session->pkt.last = session->pkt.done + dat[1];
-		if (session->pkt.last > session->pkt.total)
-			/* safety measure */
-			session->pkt.last = session->pkt.total;
-		/* TODO: do not set tx here, do it in txtask */
-		session->pkt.tx = session->pkt.done;
-	}
-	session->last_cmd = dat[0];
-	session_unlock(session);
-	if (dat[1]) {
-		j1939tp_set_rxtimeout(session, 1250);
-		if (j1939tp_im_transmitter(session->cb))
-			j1939session_schedule_txnow(session);
-	} else {
-		/* CTS(0) */
-		j1939tp_set_rxtimeout(session, 550);
-	}
-	put_session(session); /* ~j1939tp_find */
-	return;
-bad_fmt:
-	session_unlock(session);
-	j1939session_cancel(session, ABORT_FAULT);
-	put_session(session); /* ~j1939tp_find */
-}
-
-static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	int len;
-	const uint8_t *dat;
-	pgn_t pgn;
-
-	dat = skb->data;
-	pgn = j1939xtp_ctl_to_pgn(dat);
-
-	if ((tp_cmd_rts == dat[0]) && j1939cb_is_broadcast(cb)) {
-		pr_alert("%s: rts without destination (%i %02x)\n", __func__,
-			cb->ifindex, cb->src.addr);
-		return;
-	}
-	/*
-	 * TODO: abort RTS when a similar
-	 * TP is pending in the other direction
-	 */
-	session = j1939tp_find(sessionq(extd), cb, 0);
-	if (session && !j1939tp_im_transmitter(cb)) {
-		/* RTS on pending connection */
-		j1939session_cancel(session, ABORT_BUSY);
-		if ((pgn != session->cb->pgn) && (tp_cmd_bam != dat[0]))
-			j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
-		put_session(session); /* ~j1939tp_find */
-		return;
-	} else if (!session && j1939tp_im_transmitter(cb)) {
-		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
-			cb->ifindex, cb->src.addr, cb->dst.addr);
-		return;
-	}
-	if (session && (0 != session->last_cmd)) {
-		/* we received a second rts on the same connection */
-		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
-				cb->ifindex, cb->src.addr, cb->dst.addr);
-		j1939session_cancel(session, ABORT_BUSY);
-		put_session(session); /* ~j1939tp_find */
-		return;
-	}
-	if (session) {
-		/*
-		 * make sure 'sa' & 'da' are correct !
-		 * They may be 'not filled in yet' for sending
-		 * skb's, since they did not pass the Address Claim ever.
-		 */
-		session->cb->src.addr = cb->src.addr;
-		session->cb->dst.addr = cb->dst.addr;
-	} else {
-		int abort = 0;
-		if (extd) {
-			len = j1939etp_ctl_to_size(dat);
-			if (len > (max_packet_size ?: MAX_ETP_PACKET_SIZE))
-				abort = ABORT_RESOURCE;
-			else if (len <= MAX_TP_PACKET_SIZE)
-				abort = ABORT_FAULT;
-		} else {
-			len = j1939tp_ctl_to_size(dat);
-			if (len > MAX_TP_PACKET_SIZE)
-				abort = ABORT_FAULT;
-			else if (max_packet_size && (len > max_packet_size))
-				abort = ABORT_RESOURCE;
-		}
-		if (abort) {
-			j1939xtp_tx_abort(skb, extd, 1, abort, pgn);
-			return;
-		}
-		session = j1939session_fresh_new(len, cb, pgn);
-		if (!session) {
-			j1939xtp_tx_abort(skb, extd, 1, ABORT_RESOURCE, pgn);
-			return;
-		}
-		session->extd = extd;
-		/* initialize the control buffer: plain copy */
-		session->pkt.total = (len+6)/7;
-		session->pkt.block = 0xff;
-		if (!extd) {
-			if (dat[3] != session->pkt.total)
-				pr_alert("%s: strange total,"
-						" %u != %u\n", __func__,
-						session->pkt.total, dat[3]);
-			session->pkt.total = dat[3];
-			session->pkt.block = dat[4];
-		}
-		session->pkt.done = session->pkt.tx = 0;
-		get_session(session); /* equivalent to j1939tp_find() */
-		sessionlist_lock();
-		list_add_tail(&session->list, sessionq(extd));
-		sessionlist_unlock();
-	}
-	session->last_cmd = dat[0];
-
-	j1939tp_set_rxtimeout(session, 1250);
-
-	if (j1939tp_im_receiver(session->cb)) {
-		if (extd || (tp_cmd_bam != dat[0]))
-			j1939session_schedule_txnow(session);
-	}
-	/*
-	 * as soon as it's inserted, things can go fast
-	 * protect against a long delay
-	 * between spin_unlock & next statement
-	 * so, only release here, at the end
-	 */
-	put_session(session); /* ~j1939tp_find */
-	return;
-}
-
-static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	pgn_t pgn;
-	const uint8_t *dat = skb->data;
-
-	pgn = j1939xtp_ctl_to_pgn(dat);
-	session = j1939tp_find(sessionq(extd), cb, 0);
-	if (!session) {
-		pr_info("%s: %s\n", __func__, "no connection found");
-		return;
-	}
-
-	if (session->cb->pgn != pgn) {
-		pr_info("%s: different pgn\n", __func__);
-		j1939xtp_tx_abort(skb, 1, 1, ABORT_BUSY, pgn);
-		j1939session_cancel(session, ABORT_BUSY);
-		put_session(session); /* ~j1939tp_find */
-		return;
-	}
-	/* transmitted without problems */
-	session->pkt.dpo = j1939etp_ctl_to_packet(skb->data);
-	session->last_cmd = dat[0];
-	j1939tp_set_rxtimeout(session, 750);
-	put_session(session); /* ~j1939tp_find */
-}
-
-static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	const uint8_t *dat;
-	uint8_t *tpdat;
-	int offset;
-	int nbytes;
-	int final;
-	int do_cts_eof;
-	int packet;
-
-	session = j1939tp_find(sessionq(extd), cb, 0);
-	if (!session) {
-		pr_info("%s:%s\n", __func__, "no connection found");
-		return;
-	}
-	dat = skb->data;
-	if (skb->len <= 1)
-		/* makes no sense */
-		goto strange_packet_unlocked;
-
-	session_lock(session);
-
-	switch (session->last_cmd) {
-	case 0xff:
-		break;
-	case etp_cmd_dpo:
-		if (extd)
-			break;
-	case tp_cmd_bam:
-	case tp_cmd_cts:
-		if (!extd)
-			break;
-	default:
-		pr_info("%s: last %02x\n", __func__,
-				session->last_cmd);
-		goto strange_packet;
-	}
-
-	packet = (dat[0]-1+session->pkt.dpo);
-	offset = packet * 7;
-	if ((packet > session->pkt.total) ||
-			(session->pkt.done+1) > session->pkt.total) {
-		pr_info("%s: should have been completed\n", __func__);
-		goto strange_packet;
-	}
-	nbytes = session->skb->len - offset;
-	if (nbytes > 7)
-		nbytes = 7;
-	if ((nbytes <= 0) || ((nbytes + 1) > skb->len)) {
-		pr_info("%s: nbytes %i, len %i\n", __func__, nbytes,
-				skb->len);
-		goto strange_packet;
-	}
-	tpdat = session->skb->data;
-	memcpy(&tpdat[offset], &dat[1], nbytes);
-	if (packet == session->pkt.done)
-		++session->pkt.done;
-
-	if (!extd && j1939cb_is_broadcast(session->cb)) {
-		final = session->pkt.done >= session->pkt.total;
-		do_cts_eof = 0;
-	} else {
-		final = 0; /* never final, an EOF must follow */
-		do_cts_eof = (session->pkt.done >= session->pkt.last);
-	}
-	session_unlock(session);
-	if (final) {
-		j1939session_completed(session);
-	} else if (do_cts_eof) {
-		j1939tp_set_rxtimeout(session, 1250);
-		if (j1939tp_im_receiver(session->cb))
-			j1939session_schedule_txnow(session);
-	} else {
-		j1939tp_set_rxtimeout(session, 250);
-	}
-	session->last_cmd = 0xff;
-	put_session(session); /* ~j1939tp_find */
-	return;
-
-strange_packet:
-	/* unlock session (spinlock) before trying to send */
-	session_unlock(session);
-strange_packet_unlocked:
-	j1939session_cancel(session, ABORT_FAULT);
-	put_session(session); /* ~j1939tp_find */
-}
-
-/*
- * transmit function
- */
-static int j1939tp_txnext(struct session *session)
-{
-	uint8_t dat[8];
-	const uint8_t *tpdat;
-	int ret, offset, len, pkt_done, pkt_end;
-	unsigned int pkt;
-
-	memset(dat, 0xff, sizeof(dat));
-	get_session(session); /* do not loose it */
-
-	switch (session->last_cmd) {
-	case 0:
-		if (!j1939tp_im_transmitter(session->cb))
-			break;
-		dat[1] = (session->skb->len >> 0) & 0xff;
-		dat[2] = (session->skb->len >> 8) & 0xff;
-		dat[3] = session->pkt.total;
-		if (session->extd) {
-			dat[0] = etp_cmd_rts;
-			dat[1] = (session->skb->len >>  0) & 0xff;
-			dat[2] = (session->skb->len >>  8) & 0xff;
-			dat[3] = (session->skb->len >> 16) & 0xff;
-			dat[4] = (session->skb->len >> 24) & 0xff;
-		} else if (j1939cb_is_broadcast(session->cb)) {
-			dat[0] = tp_cmd_bam;
-			/* fake cts for broadcast */
-			session->pkt.tx = 0;
-		} else {
-			dat[0] = tp_cmd_rts;
-			dat[4] = dat[3];
-		}
-		if (dat[0] == session->last_txcmd)
-			/* done already */
-			break;
-		ret = j1939tp_tx_ctl(session, 0, dat);
-		if (ret < 0)
-			goto failed;
-		session->last_txcmd = dat[0];
-		/* must lock? */
-		if (tp_cmd_bam == dat[0])
-			j1939tp_schedule_txtimer(session, 50);
-		j1939tp_set_rxtimeout(session, 1250);
-		break;
-	case tp_cmd_rts:
-	case etp_cmd_rts:
-		if (!j1939tp_im_receiver(session->cb))
-			break;
-tx_cts:
-		ret = 0;
-		len = session->pkt.total - session->pkt.done;
-		if (len > 255)
-			len = 255;
-		if (len > session->pkt.block)
-			len = session->pkt.block;
-		if (block && (len > block))
-			len = block;
-
-		if (session->extd) {
-			pkt = session->pkt.done+1;
-			dat[0] = etp_cmd_cts;
-			dat[1] = len;
-			dat[2] = (pkt >>  0) & 0xff;
-			dat[3] = (pkt >>  8) & 0xff;
-			dat[4] = (pkt >> 16) & 0xff;
-		} else {
-			dat[0] = tp_cmd_cts;
-			dat[1] = len;
-			dat[2] = session->pkt.done+1;
-		}
-		if (dat[0] == session->last_txcmd)
-			/* done already */
-			break;
-		ret = j1939tp_tx_ctl(session, 1, dat);
-		if (ret < 0)
-			goto failed;
-		if (len)
-			/* only mark cts done when len is set */
-			session->last_txcmd = dat[0];
-		j1939tp_set_rxtimeout(session, 1250);
-		break;
-	case etp_cmd_cts:
-		if (j1939tp_im_transmitter(session->cb) && session->extd &&
-		    (etp_cmd_dpo != session->last_txcmd)) {
-			/* do dpo */
-			dat[0] = etp_cmd_dpo;
-			session->pkt.dpo = session->pkt.done;
-			pkt = session->pkt.dpo;
-			dat[1] = session->pkt.last - session->pkt.done;
-			dat[2] = (pkt >>  0) & 0xff;
-			dat[3] = (pkt >>  8) & 0xff;
-			dat[4] = (pkt >> 16) & 0xff;
-			ret = j1939tp_tx_ctl(session, 0, dat);
-			if (ret < 0)
-				goto failed;
-			session->last_txcmd = dat[0];
-			j1939tp_set_rxtimeout(session, 1250);
-			session->pkt.tx = session->pkt.done;
-		}
-	case tp_cmd_cts:
-	case 0xff: /* did some data */
-	case etp_cmd_dpo:
-		if ((session->extd || !j1939cb_is_broadcast(session->cb)) &&
-		     j1939tp_im_receiver(session->cb)) {
-			if (session->pkt.done >= session->pkt.total) {
-				if (session->extd) {
-					dat[0] = etp_cmd_eof;
-					dat[1] = session->skb->len >> 0;
-					dat[2] = session->skb->len >> 8;
-					dat[3] = session->skb->len >> 16;
-					dat[4] = session->skb->len >> 24;
-				} else {
-					dat[0] = tp_cmd_eof;
-					dat[1] = session->skb->len;
-					dat[2] = session->skb->len >> 8;
-					dat[3] = session->pkt.total;
-				}
-				if (dat[0] == session->last_txcmd)
-					/* done already */
-					break;
-				ret = j1939tp_tx_ctl(session, 1, dat);
-				if (ret < 0)
-					goto failed;
-				session->last_txcmd = dat[0];
-				j1939tp_set_rxtimeout(session, 1250);
-				/* wait for the EOF packet to come in */
-				break;
-			} else if (session->pkt.done >= session->pkt.last) {
-				session->last_txcmd = 0;
-				goto tx_cts;
-			}
-		}
-	case tp_cmd_bam:
-		if (!j1939tp_im_transmitter(session->cb))
-			break;
-		tpdat = session->skb->data;
-		ret = 0;
-		pkt_done = 0;
-		pkt_end = (!session->extd && j1939cb_is_broadcast(session->cb))
-			? session->pkt.total : session->pkt.last;
-
-		while (session->pkt.tx < pkt_end) {
-			dat[0] = session->pkt.tx - session->pkt.dpo+1;
-			offset = session->pkt.tx * 7;
-			len = session->skb->len - offset;
-			if (len > 7)
-				len = 7;
-			memcpy(&dat[1], &tpdat[offset], len);
-			ret = j1939tp_tx_dat(session, dat, len+1);
-			if (ret < 0)
-				break;
-			session->last_txcmd = 0xff;
-			++pkt_done;
-			++session->pkt.tx;
-			if (j1939cb_is_broadcast(session->cb)) {
-				if (session->pkt.tx < session->pkt.total)
-					j1939tp_schedule_txtimer(session, 50);
-				break;
-			}
-		}
-		if (pkt_done)
-			j1939tp_set_rxtimeout(session, 250);
-		if (ret)
-			goto failed;
-		break;
-	}
-	put_session(session);
-	return 0;
-failed:
-	put_session(session);
-	return ret;
-}
-
-static void j1939tp_txtask(unsigned long val)
-{
-	struct session *session = (void *)val;
-	int ret;
-
-	get_session(session);
-	ret = j1939tp_txnext(session);
-	if (ret < 0)
-		j1939tp_schedule_txtimer(session, retry_ms);
-	put_session(session);
-}
-
-static inline int j1939tp_tx_initial(struct session *session)
-{
-	int ret;
-
-	get_session(session);
-	ret = j1939tp_txnext(session);
-	/* set nonblocking for further packets */
-	session->cb->msg_flags |= MSG_DONTWAIT;
-	put_session(session);
-	return ret;
-}
-
-/* this call is to be used as probe within wait_event_xxx() */
-static int j1939session_insert(struct session *session)
-{
-	struct session *pending;
-
-	sessionlist_lock();
-	pending = _j1939tp_find(sessionq(session->extd), session->cb, 0);
-	if (pending)
-		/* revert the effect of find() */
-		put_session(pending);
-	else
-		list_add_tail(&session->list, sessionq(session->extd));
-	sessionlist_unlock();
-	return pending ? 0 : 1;
-}
-/*
- * j1939 main intf
- */
-int j1939_send_transport(struct sk_buff *skb)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	struct session *session;
-	int ret;
-
-	if ((tp_pgn_dat == cb->pgn) || (tp_pgn_ctl == cb->pgn) ||
-	    (etp_pgn_dat == cb->pgn) || (etp_pgn_ctl == cb->pgn))
-		/* avoid conflict */
-		return -EDOM;
-	if (skb->len <= 8)
-		return 0;
-	else if (skb->len > (max_packet_size ?: MAX_ETP_PACKET_SIZE))
-		return -EMSGSIZE;
-
-	if (skb->len > MAX_TP_PACKET_SIZE) {
-		if (j1939cb_is_broadcast(cb))
-			return -EDESTADDRREQ;
-	}
-
-	/* prepare new session */
-	session = j1939session_new(skb);
-	if (!session)
-		return -ENOMEM;
-
-	session->extd = (skb->len > MAX_TP_PACKET_SIZE) ? EXTENDED : REGULAR;
-	session->transmission = 1;
-	session->pkt.total = (skb->len + 6)/7;
-	session->pkt.block = session->extd ? 255 :
-		(block ?: session->pkt.total);
-	if (j1939cb_is_broadcast(session->cb))
-		/* set the end-packet for broadcast */
-		session->pkt.last = session->pkt.total;
-
-	/* insert into queue, but avoid collision with pending session */
-	if (session->cb->msg_flags & MSG_DONTWAIT)
-		ret = j1939session_insert(session) ? 0 : -EAGAIN;
-	else
-		ret = wait_event_interruptible(s.wait,
-				j1939session_insert(session));
-	if (ret < 0)
-		goto failed;
-
-	ret = j1939tp_tx_initial(session);
-	if (!ret)
-		/* transmission started */
-		return RESULT_STOP;
-	sessionlist_lock();
-	list_del_init(&session->list);
-	sessionlist_unlock();
-failed:
-	/*
-	 * hide the skb from j1939session_drop, as it would
-	 * kfree_skb, but our caller will kfree_skb(skb) too.
-	 */
-	session->skb = NULL;
-	j1939session_drop(session);
-	return ret;
-}
-
-int j1939_recv_transport(struct sk_buff *skb)
-{
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	const uint8_t *dat;
-
-	switch (cb->pgn) {
-	case etp_pgn_dat:
-		j1939xtp_rx_dat(skb, EXTENDED);
-		break;
-	case etp_pgn_ctl:
-		if (skb->len < 8) {
-			j1939xtp_rx_bad_message(skb, EXTENDED);
-			break;
-		}
-		dat = skb->data;
-		switch (*dat) {
-		case etp_cmd_rts:
-			j1939xtp_rx_rts(skb, EXTENDED);
-			break;
-		case etp_cmd_cts:
-			j1939xtp_rx_cts(skb, EXTENDED);
-			break;
-		case etp_cmd_dpo:
-			j1939xtp_rx_dpo(skb, EXTENDED);
-			break;
-		case etp_cmd_eof:
-			j1939xtp_rx_eof(skb, EXTENDED);
-			break;
-		case etp_cmd_abort:
-			j1939xtp_rx_abort(skb, EXTENDED);
-			break;
-		default:
-			j1939xtp_rx_bad_message(skb, EXTENDED);
-			break;
-		}
-		break;
-	case tp_pgn_dat:
-		j1939xtp_rx_dat(skb, REGULAR);
-		break;
-	case tp_pgn_ctl:
-		if (skb->len < 8) {
-			j1939xtp_rx_bad_message(skb, REGULAR);
-			break;
-		}
-		dat = skb->data;
-		switch (*dat) {
-		case tp_cmd_bam:
-		case tp_cmd_rts:
-			j1939xtp_rx_rts(skb, REGULAR);
-			break;
-		case tp_cmd_cts:
-			j1939xtp_rx_cts(skb, REGULAR);
-			break;
-		case tp_cmd_eof:
-			j1939xtp_rx_eof(skb, REGULAR);
-			break;
-		case tp_cmd_abort:
-			j1939xtp_rx_abort(skb, REGULAR);
-			break;
-		default:
-			j1939xtp_rx_bad_message(skb, REGULAR);
-			break;
-		}
-		break;
-	default:
-		return 0;
-	}
-	return RESULT_STOP;
-}
-
-static struct session *j1939session_fresh_new(int size,
-		struct j1939_sk_buff_cb *rel_cb, pgn_t pgn)
-{
-	struct sk_buff *skb;
-	struct j1939_sk_buff_cb *cb;
-	struct session *session;
-
-	skb = dev_alloc_skb(size);
-	if (!skb)
-		return NULL;
-	cb = (void *)skb->cb;
-	*cb = *rel_cb;
-	fix_cb(cb);
-	cb->pgn = pgn;
-
-	session = j1939session_new(skb);
-	if (!session) {
-		kfree(skb);
-		return NULL;
-	}
-	/* alloc data area */
-	skb_put(skb, size);
-	return session;
-}
-static struct session *j1939session_new(struct sk_buff *skb)
-{
-	struct session *session;
-
-	session = kzalloc(sizeof(*session), gfp_any());
-	if (!session)
-		return NULL;
-	INIT_LIST_HEAD(&session->list);
-	spin_lock_init(&session->lock);
-	session->skb = skb;
-
-	session->cb = (void *)session->skb->cb;
-	hrtimer_init(&session->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	session->txtimer.function = j1939tp_txtimer;
-	hrtimer_init(&session->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	session->rxtimer.function = j1939tp_rxtimer;
-	tasklet_init(&session->txtask, j1939tp_txtask, (unsigned long)session);
-	tasklet_init(&session->rxtask, j1939tp_rxtask, (unsigned long)session);
-	return session;
-}
-
-static int j1939tp_notifier(struct notifier_block *nb,
-			unsigned long msg, void *data)
-{
-	struct net_device *netdev = (struct net_device *)data;
-	struct session *session, *saved;
-
-	if (!net_eq(dev_net(netdev), &init_net))
-		return NOTIFY_DONE;
-
-	if (netdev->type != ARPHRD_CAN)
-		return NOTIFY_DONE;
-
-	if (msg != NETDEV_UNREGISTER)
-		return NOTIFY_DONE;
-
-	sessionlist_lock();
-	list_for_each_entry_safe(session, saved, &s.sessionq, list) {
-		if (session->cb->ifindex != netdev->ifindex)
-			continue;
-		list_del_init(&session->list);
-		put_session(session);
-	}
-	list_for_each_entry_safe(session, saved, &s.extsessionq, list) {
-		if (session->cb->ifindex != netdev->ifindex)
-			continue;
-		list_del_init(&session->list);
-		put_session(session);
-	}
-	sessionlist_unlock();
-	return NOTIFY_DONE;
-}
-
-/* SYSCTL */
-static struct ctl_table_header *j1939tp_table_header;
-
-static int min_block = 1;
-static int max_block = 255;
-static int min_packet = 8;
-static int max_packet = ((2 << 24)-1)*7;
-
-static int min_retry = 5;
-static int max_retry = 5000;
-
-static ctl_table j1939tp_table[] = {
-	{
-		.procname	= "transport_cts_nr_of_frames",
-		.data		= &block,
-		.maxlen		= sizeof(block),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
-		.extra1		= &min_block,
-		.extra2		= &max_block,
-	},
-	{
-		.procname	= "transport_max_payload_in_bytes",
-		.data		= &max_packet_size,
-		.maxlen		= sizeof(max_packet_size),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
-		.extra1		= &min_packet,
-		.extra2		= &max_packet,
-	},
-	{
-		.procname	= "transport_tx_retry_ms",
-		.data		= &retry_ms,
-		.maxlen		= sizeof(retry_ms),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
-		.extra1		= &min_retry,
-		.extra2		= &max_retry,
-	},
-	{ },
-};
-
-static struct ctl_path j1939tp_path[] = {
-	{ .procname = "net", },
-	{ .procname = j1939_procname, },
-	{ }
-};
-
-/* PROC */
-static int j1939tp_proc_show_session(struct seq_file *sqf,
-		struct session *session)
-{
-	seq_printf(sqf, "%i", session->cb->ifindex);
-	if (session->cb->src.name)
-		seq_printf(sqf, "\t%016llx", session->cb->src.name);
-	else
-		seq_printf(sqf, "\t%02x", session->cb->src.addr);
-	if (session->cb->dst.name)
-		seq_printf(sqf, "\t%016llx", session->cb->dst.name);
-	else if (j1939_address_is_unicast(session->cb->dst.addr))
-		seq_printf(sqf, "\t%02x", session->cb->dst.addr);
-	else
-		seq_printf(sqf, "\t-");
-	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
-			session->pkt.done*7, session->skb->len);
-	return 0;
-}
-
-static int j1939tp_proc_show(struct seq_file *sqf, void *v)
-{
-	struct session *session;
-
-	seq_printf(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
-	sessionlist_lock();
-	list_for_each_entry(session, &s.sessionq, list)
-		j1939tp_proc_show_session(sqf, session);
-	list_for_each_entry(session, &s.extsessionq, list)
-		j1939tp_proc_show_session(sqf, session);
-	sessionlist_unlock();
-	return 0;
-}
-
-int __init j1939tp_module_init(void)
-{
-	spin_lock_init(&s.lock);
-	INIT_LIST_HEAD(&s.sessionq);
-	INIT_LIST_HEAD(&s.extsessionq);
-	spin_lock_init(&s.del.lock);
-	INIT_LIST_HEAD(&s.del.sessionq);
-	INIT_WORK(&s.del.work, j1939tp_del_work);
-
-	s.notifier.notifier_call = j1939tp_notifier;
-	register_netdevice_notifier(&s.notifier);
-
-	j1939_proc_add("transport", j1939tp_proc_show, NULL);
-	j1939tp_table_header =
-		register_sysctl_paths(j1939tp_path, j1939tp_table);
-	init_waitqueue_head(&s.wait);
-	return 0;
-}
-
-void j1939tp_module_exit(void)
-{
-	struct session *session, *saved;
-
-	wake_up_all(&s.wait);
-
-	unregister_sysctl_table(j1939tp_table_header);
-	unregister_netdevice_notifier(&s.notifier);
-	j1939_proc_remove("transport");
-	sessionlist_lock();
-	list_for_each_entry_safe(session, saved, &s.extsessionq, list) {
-		list_del_init(&session->list);
-		put_session(session);
-	}
-	list_for_each_entry_safe(session, saved, &s.sessionq, list) {
-		list_del_init(&session->list);
-		put_session(session);
-	}
-	sessionlist_unlock();
-	flush_scheduled_work();
-}
-
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/skbuff.h>
+#include <linux/hrtimer.h>
+#include <linux/version.h>
+#include <linux/if_arp.h>
+#include <linux/wait.h>
+#include "j1939-priv.h"
+
+#define REGULAR		0
+#define EXTENDED	1
+
+#define etp_pgn_ctl	0xc800
+#define etp_pgn_dat	0xc700
+#define tp_pgn_ctl	0xec00
+#define tp_pgn_dat	0xeb00
+
+#define  tp_cmd_bam	0x20
+#define  tp_cmd_rts	0x10
+#define  tp_cmd_cts	0x11
+#define  tp_cmd_eof	0x13
+#define  tp_cmd_abort	0xff
+
+#define etp_cmd_rts	0x14
+#define etp_cmd_cts	0x15
+#define etp_cmd_dpo	0x16
+#define etp_cmd_eof	0x17
+#define etp_cmd_abort	0xff
+
+#define ABORT_BUSY	1
+#define ABORT_RESOURCE	2
+#define ABORT_TIMEOUT	3
+#define ABORT_GENERIC	4
+#define ABORT_FAULT	5
+
+#define MAX_TP_PACKET_SIZE	(7*255)
+#define MAX_ETP_PACKET_SIZE	(7*0xffffff)
+
+static int block = 255;
+static int max_packet_size = 1024*100;
+static int retry_ms = 20;
+
+struct session {
+	struct list_head list;
+	atomic_t refs;
+	spinlock_t lock;
+
+	struct j1939_sk_buff_cb *cb; /*
+	 * ifindex, src, dst, pgn define the session block
+	 * the are _never_ modified after insertion in the list
+	 * this decreases locking problems a _lot_
+	 */
+	struct sk_buff *skb;
+
+	/*
+	 * all tx related stuff (last_txcmd, pkt.tx)
+	 * is protected (modified only) with the txtask tasklet
+	 * 'total' & 'block' are never changed,
+	 * last_cmd, last & block are protected by ->lock
+	 * this means that the tx may run after cts is received that should
+	 * have stopped tx, but this time discrepancy is never avoided anyhow
+	 */
+	uint8_t last_cmd, last_txcmd;
+	uint8_t transmission;
+	uint8_t extd;
+	struct {
+		/*
+		 * these do not require 16 bit, they should fit in uint8_t
+		 * but putting in int makes it easier to deal with
+		 */
+		unsigned int total, done, last, tx;
+		unsigned int block; /* for TP */
+		unsigned int dpo; /* for ETP */
+	} pkt;
+	struct hrtimer txtimer, rxtimer;
+	/* tasklets for execution of tx/rx timer hander in softirq */
+	struct tasklet_struct txtask, rxtask;
+};
+
+static struct j1939tp {
+	spinlock_t lock;
+	struct list_head sessionq;
+	struct list_head extsessionq;
+	struct {
+		struct list_head sessionq;
+		spinlock_t lock;
+		struct work_struct work;
+	} del;
+	wait_queue_head_t wait;
+	struct notifier_block notifier;
+} s;
+
+static struct session *j1939session_new(struct sk_buff *skb);
+static struct session *j1939session_fresh_new(int size,
+		struct j1939_sk_buff_cb *rel_cb, pgn_t pgn);
+
+static inline void fix_cb(struct j1939_sk_buff_cb *cb)
+{
+	cb->msg_flags &= ~J1939_MSG_RESERVED;
+}
+
+static inline struct list_head *sessionq(int extd)
+{
+	return extd ? &s.extsessionq : &s.sessionq;
+}
+
+static inline void j1939session_destroy(struct session *session)
+{
+	if (session->skb)
+		kfree_skb(session->skb);
+	hrtimer_cancel(&session->rxtimer);
+	hrtimer_cancel(&session->txtimer);
+	tasklet_disable(&session->rxtask);
+	tasklet_disable(&session->txtask);
+	kfree(session);
+}
+
+/* clean up work queue */
+static void j1939tp_del_work(struct work_struct *work)
+{
+	struct session *session;
+	int cnt = 0;
+
+	do {
+		session = NULL;
+		spin_lock_bh(&s.del.lock);
+		if (list_empty(&s.del.sessionq)) {
+			spin_unlock_bh(&s.del.lock);
+			break;
+		}
+		session = list_first_entry(&s.del.sessionq,
+				struct session, list);
+		list_del_init(&session->list);
+		spin_unlock_bh(&s.del.lock);
+		j1939session_destroy(session);
+		++cnt;
+	} while (1);
+}
+/* reference counter */
+static inline void get_session(struct session *session)
+{
+	atomic_inc(&session->refs);
+}
+
+static void put_session(struct session *session)
+{
+	BUG_ON(!session);
+	if (atomic_add_return(-1, &session->refs) >= 0)
+		/* not the last one */
+		return;
+	/* it should have been removed from any list long time ago */
+	BUG_ON(!list_empty(&session->list));
+
+	hrtimer_try_to_cancel(&session->rxtimer);
+	hrtimer_try_to_cancel(&session->txtimer);
+	tasklet_disable_nosync(&session->rxtask);
+	tasklet_disable_nosync(&session->txtask);
+
+	if (in_interrupt()) {
+		spin_lock_bh(&s.del.lock);
+		list_add_tail(&session->list, &s.del.sessionq);
+		spin_unlock_bh(&s.del.lock);
+		schedule_work(&s.del.work);
+	} else {
+		/* destroy session right here */
+		j1939session_destroy(session);
+	}
+}
+
+/* transport status locking */
+static inline void session_lock(struct session *session)
+{
+	get_session(session); /* safety measure */
+	spin_lock_bh(&session->lock);
+}
+
+static inline void session_unlock(struct session *session)
+{
+	spin_unlock_bh(&session->lock);
+	put_session(session);
+}
+
+static inline void sessionlist_lock(void)
+{
+	spin_lock_bh(&s.lock);
+}
+
+static inline void sessionlist_unlock(void)
+{
+	spin_unlock_bh(&s.lock);
+}
+
+/*
+ * see if we are receiver
+ * returns 0 for broadcasts, although we will receive them
+ */
+static inline int j1939tp_im_receiver(const struct j1939_sk_buff_cb *cb)
+{
+	return (cb->dst.flags & ECUFLAG_LOCAL) ? 1 : 0;
+}
+
+/* see if we are sender */
+static inline int j1939tp_im_transmitter(const struct j1939_sk_buff_cb *cb)
+{
+	return (cb->src.flags & ECUFLAG_LOCAL) ? 1 : 0;
+}
+
+/* see if we are involved as either receiver or transmitter */
+/* reverse = -1 means : any direction */
+static int j1939tp_im_involved(const struct j1939_sk_buff_cb *cb, int reverse)
+{
+	if (reverse < 0) {
+		return ((cb->src.flags | cb->dst.flags) & ECUFLAG_LOCAL)
+			? 1 : 0;
+	} else if (reverse) {
+		return j1939tp_im_receiver(cb);
+	} else {
+		return j1939tp_im_transmitter(cb);
+	}
+}
+
+/* extract pgn from flow-ctl message */
+static inline pgn_t j1939xtp_ctl_to_pgn(const uint8_t *dat)
+{
+	pgn_t pgn;
+
+	pgn = (dat[7] << 16) | (dat[6] << 8) | (dat[5] << 0);
+	if (pgn_is_pdu1(pgn))
+		pgn &= 0xffff00;
+	return pgn;
+}
+
+static inline unsigned int j1939tp_ctl_to_size(const uint8_t *dat)
+{
+	return (dat[2] << 8) + (dat[1] << 0);
+}
+static inline unsigned int j1939etp_ctl_to_packet(const uint8_t *dat)
+{
+	return (dat[4] << 16) | (dat[3] << 8) | (dat[2] << 0);
+}
+static inline unsigned int j1939etp_ctl_to_size(const uint8_t *dat)
+{
+	return (dat[4] << 24) | (dat[3] << 16) |
+		(dat[2] << 8) | (dat[1] << 0);
+}
+
+/*
+ * find existing session:
+ * reverse: swap cb's src & dst
+ * there is no problem with matching broadcasts, since
+ * broadcasts (no dst, no da) would never call this
+ * with reverse==1
+ */
+static int j1939tp_match(const struct j1939_sk_buff_cb *a,
+		const struct j1939_sk_buff_cb *b, int reverse)
+{
+	if (a->ifindex != b->ifindex)
+		return 0;
+	if (!reverse) {
+		if (a->src.name) {
+			if (a->src.name != b->src.name)
+				return 0;
+		} else if (a->src.addr != b->src.addr)
+			return 0;
+		if (a->dst.name) {
+			if (a->dst.name != b->dst.name)
+				return 0;
+		} else if (a->dst.addr != b->dst.addr)
+			return 0;
+	} else {
+		if (a->src.name) {
+			if (a->src.name != b->dst.name)
+				return 0;
+		} else if (a->src.addr != b->dst.addr)
+			return 0;
+		if (a->dst.name) {
+			if (a->dst.name != b->src.name)
+				return 0;
+		} else if (a->dst.addr != b->src.addr)
+			return 0;
+	}
+	return 1;
+}
+
+static struct session *_j1939tp_find(struct list_head *root,
+		const struct j1939_sk_buff_cb *cb, int reverse)
+{
+	struct session *session;
+
+	list_for_each_entry(session, root, list) {
+		get_session(session);
+		if (j1939tp_match(session->cb, cb, reverse))
+			return session;
+		put_session(session);
+	}
+	return NULL;
+}
+
+static struct session *j1939tp_find(struct list_head *root,
+		const struct j1939_sk_buff_cb *cb, int reverse)
+{
+	struct session *session;
+	sessionlist_lock();
+	session = _j1939tp_find(root, cb, reverse);
+	sessionlist_unlock();
+	return session;
+}
+
+static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
+{
+	name_t name;
+	uint8_t addr;
+	int flags;
+
+	name = cb->dst.name;
+	cb->dst.name = cb->src.name;
+	cb->src.name = name;
+
+	addr = cb->dst.addr;
+	cb->dst.addr = cb->src.addr;
+	cb->src.addr = addr;
+
+	flags = cb->dst.flags;
+	cb->dst.flags = cb->src.flags;
+	cb->src.flags = flags;
+}
+/* TP transmit packet functions */
+static int j1939tp_tx_dat(struct session *related,
+		const uint8_t *dat, int len)
+{
+	int ret;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb;
+	uint8_t *skdat;
+
+	skb = dev_alloc_skb(8);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	skb->protocol = related->skb->protocol;
+	skb->pkt_type = related->skb->pkt_type;
+	skb->ip_summed = related->skb->ip_summed;
+	skb->sk	= related->skb->sk;
+
+	skb_cb = (void *)skb->cb;
+	*skb_cb = *(related->cb);
+	fix_cb(skb_cb);
+	/* fix pgn */
+	skb_cb->pgn = related->extd ? etp_pgn_dat : tp_pgn_dat;
+
+	skdat = skb_put(skb, len);
+	memcpy(skdat, dat, len);
+	ret = j1939_send(skb, j1939_level_transport);
+	if (ret < 0)
+		kfree_skb(skb);
+	return ret;
+}
+
+static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
+		int swap_src_dst, pgn_t pgn, const uint8_t dat[5])
+{
+	int ret;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb, *rel_cb;
+	uint8_t *skdat;
+
+	rel_cb = (void *)related->cb;
+	if (!j1939tp_im_involved(rel_cb, swap_src_dst))
+		return 0;
+
+	skb = dev_alloc_skb(8);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	skb->protocol = related->protocol;
+	skb->pkt_type = related->pkt_type;
+	skb->ip_summed = related->ip_summed;
+	skb->sk	= related->sk;
+
+	skb_cb = (void *)skb->cb;
+	*skb_cb = *rel_cb;
+	fix_cb(skb_cb);
+	if (swap_src_dst)
+		j1939_skbcb_swap(skb_cb);
+	skb_cb->pgn = extd ? etp_pgn_ctl : tp_pgn_ctl;
+
+	skdat = skb_put(skb, 8);
+	memcpy(skdat, dat, 5);
+	skdat[7] = (pgn >> 16) & 0xff;
+	skdat[6] = (pgn >>  8) & 0xff;
+	skdat[5] = (pgn >>  0) & 0xff;
+
+	ret = j1939_send(skb, j1939_level_transport);
+	if (ret)
+		kfree_skb(skb);
+	return ret;
+}
+
+static inline int j1939tp_tx_ctl(struct session *session,
+		int swap_src_dst, const uint8_t dat[8])
+{
+	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
+			session->cb->pgn, dat);
+}
+
+static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
+		int swap_src_dst, int err, pgn_t pgn)
+{
+	struct j1939_sk_buff_cb *cb = (void *)related->cb;
+	uint8_t dat[5];
+
+	if (!j1939tp_im_involved(cb, swap_src_dst))
+		return 0;
+
+	memset(dat, 0xff, sizeof(dat));
+	dat[0] = tp_cmd_abort;
+	if (!extd)
+		dat[1] = err ?: ABORT_GENERIC;
+	return j1939xtp_do_tx_ctl(related, extd, swap_src_dst, pgn, dat);
+}
+
+/* timer & scheduler functions */
+static inline void j1939session_schedule_txnow(struct session *session)
+{
+	tasklet_schedule(&session->txtask);
+}
+static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
+{
+	struct session *session =
+		container_of(hrtimer, struct session, txtimer);
+	j1939session_schedule_txnow(session);
+	return HRTIMER_NORESTART;
+}
+static inline void j1939tp_schedule_txtimer(struct session *session, int msec)
+{
+	hrtimer_start(&session->txtimer,
+			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
+			HRTIMER_MODE_REL);
+}
+static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
+{
+	hrtimer_start(&session->rxtimer,
+			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
+			HRTIMER_MODE_REL);
+}
+
+/*
+ * session completion functions
+ */
+/*
+ * j1939session_drop
+ * removes a session from open session list
+ */
+static inline void j1939session_drop(struct session *session)
+{
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+
+	if (session->transmission) {
+		if (session->skb && session->skb->sk)
+			j1939_sock_pending_del(session->skb->sk);
+		wake_up_all(&s.wait);
+	}
+	put_session(session);
+}
+
+static inline void j1939session_completed(struct session *session)
+{
+	j1939_recv(session->skb, j1939_level_transport);
+	j1939session_drop(session);
+}
+
+static void j1939session_cancel(struct session *session, int err)
+{
+	if ((err >= 0) && j1939tp_im_involved(session->cb, -1)) {
+		if (!j1939cb_is_broadcast(session->cb)) {
+			/* do not send aborts on incoming broadcasts */
+			j1939xtp_tx_abort(session->skb, session->extd,
+				!j1939tp_im_transmitter(session->cb),
+				err, session->cb->pgn);
+		}
+	}
+	j1939session_drop(session);
+}
+
+static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
+{
+	struct session *session =
+		container_of(hrtimer, struct session, rxtimer);
+	tasklet_schedule(&session->rxtask);
+	return HRTIMER_NORESTART;
+}
+
+static void j1939tp_rxtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+
+	get_session(session);
+	pr_alert("%s: timeout on %i\n", __func__, session->cb->ifindex);
+	j1939session_cancel(session, ABORT_TIMEOUT);
+	put_session(session);
+}
+
+/*
+ * receive packet functions
+ */
+static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (session /*&& (session->cb->pgn == pgn)*/) {
+		/* do not allow TP control messages on 2 pgn's */
+		j1939session_cancel(session, ABORT_FAULT);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	j1939xtp_tx_abort(skb, extd, 0, ABORT_FAULT, pgn);
+	if (!session)
+		return;
+	put_session(session); /* ~j1939tp_find */
+}
+
+/* abort packets may come in 2 directions */
+static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
+	_j1939xtp_rx_bad_message(skb, extd);
+	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_bad_message(skb, extd);
+	/* restore skb */
+	j1939_skbcb_swap(cb);
+	return;
+}
+
+static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (!session)
+		return;
+	if (session->transmission && !session->last_txcmd) {
+		/*
+		 * empty block:
+		 * do not drop session when a transmit session did not
+		 * start yet
+		 */
+	} else if (session->cb->pgn == pgn)
+		j1939session_drop(session);
+	/* another PGN had a bad message */
+	/*
+	 * TODO: maybe cancel current connection
+	 * as another pgn was communicated
+	 */
+	put_session(session); /* ~j1939tp_find */
+}
+/* abort packets may come in 2 directions */
+static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s %i, %05x\n", __func__, cb->ifindex,
+			j1939xtp_ctl_to_pgn(skb->data));
+	_j1939xtp_rx_abort(skb, extd);
+	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_abort(skb, extd);
+	/* restore skb */
+	j1939_skbcb_swap(cb);
+	return;
+}
+
+static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+
+	/* end of tx cycle */
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 1);
+	if (!session)
+		/*
+		 * strange, we had EOF on closed connection
+		 * do nothing, as EOF closes the connection anyway
+		 */
+		return;
+
+	if (session->cb->pgn != pgn) {
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+	} else {
+		/* transmitted without problems */
+		j1939session_completed(session);
+	}
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+	unsigned int pkt;
+	const uint8_t *dat;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 1);
+	if (!session) {
+		/* 'CTS shall be ignored' */
+		return;
+	}
+	if (session->cb->pgn != pgn) {
+		/* what to do? */
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	session_lock(session);
+	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
+	if (!dat[0])
+		hrtimer_cancel(&session->txtimer);
+	else if (!pkt)
+		goto bad_fmt;
+	else if (dat[1] > session->pkt.block /* 0xff for etp */)
+		goto bad_fmt;
+	else {
+		/* set packet counters only when not CTS(0) */
+		session->pkt.done = pkt - 1;
+		session->pkt.last = session->pkt.done + dat[1];
+		if (session->pkt.last > session->pkt.total)
+			/* safety measure */
+			session->pkt.last = session->pkt.total;
+		/* TODO: do not set tx here, do it in txtask */
+		session->pkt.tx = session->pkt.done;
+	}
+	session->last_cmd = dat[0];
+	session_unlock(session);
+	if (dat[1]) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_transmitter(session->cb))
+			j1939session_schedule_txnow(session);
+	} else {
+		/* CTS(0) */
+		j1939tp_set_rxtimeout(session, 550);
+	}
+	put_session(session); /* ~j1939tp_find */
+	return;
+bad_fmt:
+	session_unlock(session);
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int len;
+	const uint8_t *dat;
+	pgn_t pgn;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(dat);
+
+	if ((tp_cmd_rts == dat[0]) && j1939cb_is_broadcast(cb)) {
+		pr_alert("%s: rts without destination (%i %02x)\n", __func__,
+			cb->ifindex, cb->src.addr);
+		return;
+	}
+	/*
+	 * TODO: abort RTS when a similar
+	 * TP is pending in the other direction
+	 */
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (session && !j1939tp_im_transmitter(cb)) {
+		/* RTS on pending connection */
+		j1939session_cancel(session, ABORT_BUSY);
+		if ((pgn != session->cb->pgn) && (tp_cmd_bam != dat[0]))
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	} else if (!session && j1939tp_im_transmitter(cb)) {
+		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
+			cb->ifindex, cb->src.addr, cb->dst.addr);
+		return;
+	}
+	if (session && (0 != session->last_cmd)) {
+		/* we received a second rts on the same connection */
+		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
+				cb->ifindex, cb->src.addr, cb->dst.addr);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	if (session) {
+		/*
+		 * make sure 'sa' & 'da' are correct !
+		 * They may be 'not filled in yet' for sending
+		 * skb's, since they did not pass the Address Claim ever.
+		 */
+		session->cb->src.addr = cb->src.addr;
+		session->cb->dst.addr = cb->dst.addr;
+	} else {
+		int abort = 0;
+		if (extd) {
+			len = j1939etp_ctl_to_size(dat);
+			if (len > (max_packet_size ?: MAX_ETP_PACKET_SIZE))
+				abort = ABORT_RESOURCE;
+			else if (len <= MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+		} else {
+			len = j1939tp_ctl_to_size(dat);
+			if (len > MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+			else if (max_packet_size && (len > max_packet_size))
+				abort = ABORT_RESOURCE;
+		}
+		if (abort) {
+			j1939xtp_tx_abort(skb, extd, 1, abort, pgn);
+			return;
+		}
+		session = j1939session_fresh_new(len, cb, pgn);
+		if (!session) {
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_RESOURCE, pgn);
+			return;
+		}
+		session->extd = extd;
+		/* initialize the control buffer: plain copy */
+		session->pkt.total = (len+6)/7;
+		session->pkt.block = 0xff;
+		if (!extd) {
+			if (dat[3] != session->pkt.total)
+				pr_alert("%s: strange total,"
+						" %u != %u\n", __func__,
+						session->pkt.total, dat[3]);
+			session->pkt.total = dat[3];
+			session->pkt.block = dat[4];
+		}
+		session->pkt.done = session->pkt.tx = 0;
+		get_session(session); /* equivalent to j1939tp_find() */
+		sessionlist_lock();
+		list_add_tail(&session->list, sessionq(extd));
+		sessionlist_unlock();
+	}
+	session->last_cmd = dat[0];
+
+	j1939tp_set_rxtimeout(session, 1250);
+
+	if (j1939tp_im_receiver(session->cb)) {
+		if (extd || (tp_cmd_bam != dat[0]))
+			j1939session_schedule_txnow(session);
+	}
+	/*
+	 * as soon as it's inserted, things can go fast
+	 * protect against a long delay
+	 * between spin_unlock & next statement
+	 * so, only release here, at the end
+	 */
+	put_session(session); /* ~j1939tp_find */
+	return;
+}
+
+static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+	const uint8_t *dat = skb->data;
+
+	pgn = j1939xtp_ctl_to_pgn(dat);
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (!session) {
+		pr_info("%s: %s\n", __func__, "no connection found");
+		return;
+	}
+
+	if (session->cb->pgn != pgn) {
+		pr_info("%s: different pgn\n", __func__);
+		j1939xtp_tx_abort(skb, 1, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	/* transmitted without problems */
+	session->pkt.dpo = j1939etp_ctl_to_packet(skb->data);
+	session->last_cmd = dat[0];
+	j1939tp_set_rxtimeout(session, 750);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	const uint8_t *dat;
+	uint8_t *tpdat;
+	int offset;
+	int nbytes;
+	int final;
+	int do_cts_eof;
+	int packet;
+
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (!session) {
+		pr_info("%s:%s\n", __func__, "no connection found");
+		return;
+	}
+	dat = skb->data;
+	if (skb->len <= 1)
+		/* makes no sense */
+		goto strange_packet_unlocked;
+
+	session_lock(session);
+
+	switch (session->last_cmd) {
+	case 0xff:
+		break;
+	case etp_cmd_dpo:
+		if (extd)
+			break;
+	case tp_cmd_bam:
+	case tp_cmd_cts:
+		if (!extd)
+			break;
+	default:
+		pr_info("%s: last %02x\n", __func__,
+				session->last_cmd);
+		goto strange_packet;
+	}
+
+	packet = (dat[0]-1+session->pkt.dpo);
+	offset = packet * 7;
+	if ((packet > session->pkt.total) ||
+			(session->pkt.done+1) > session->pkt.total) {
+		pr_info("%s: should have been completed\n", __func__);
+		goto strange_packet;
+	}
+	nbytes = session->skb->len - offset;
+	if (nbytes > 7)
+		nbytes = 7;
+	if ((nbytes <= 0) || ((nbytes + 1) > skb->len)) {
+		pr_info("%s: nbytes %i, len %i\n", __func__, nbytes,
+				skb->len);
+		goto strange_packet;
+	}
+	tpdat = session->skb->data;
+	memcpy(&tpdat[offset], &dat[1], nbytes);
+	if (packet == session->pkt.done)
+		++session->pkt.done;
+
+	if (!extd && j1939cb_is_broadcast(session->cb)) {
+		final = session->pkt.done >= session->pkt.total;
+		do_cts_eof = 0;
+	} else {
+		final = 0; /* never final, an EOF must follow */
+		do_cts_eof = (session->pkt.done >= session->pkt.last);
+	}
+	session_unlock(session);
+	if (final) {
+		j1939session_completed(session);
+	} else if (do_cts_eof) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_receiver(session->cb))
+			j1939session_schedule_txnow(session);
+	} else {
+		j1939tp_set_rxtimeout(session, 250);
+	}
+	session->last_cmd = 0xff;
+	put_session(session); /* ~j1939tp_find */
+	return;
+
+strange_packet:
+	/* unlock session (spinlock) before trying to send */
+	session_unlock(session);
+strange_packet_unlocked:
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+/*
+ * transmit function
+ */
+static int j1939tp_txnext(struct session *session)
+{
+	uint8_t dat[8];
+	const uint8_t *tpdat;
+	int ret, offset, len, pkt_done, pkt_end;
+	unsigned int pkt;
+
+	memset(dat, 0xff, sizeof(dat));
+	get_session(session); /* do not loose it */
+
+	switch (session->last_cmd) {
+	case 0:
+		if (!j1939tp_im_transmitter(session->cb))
+			break;
+		dat[1] = (session->skb->len >> 0) & 0xff;
+		dat[2] = (session->skb->len >> 8) & 0xff;
+		dat[3] = session->pkt.total;
+		if (session->extd) {
+			dat[0] = etp_cmd_rts;
+			dat[1] = (session->skb->len >>  0) & 0xff;
+			dat[2] = (session->skb->len >>  8) & 0xff;
+			dat[3] = (session->skb->len >> 16) & 0xff;
+			dat[4] = (session->skb->len >> 24) & 0xff;
+		} else if (j1939cb_is_broadcast(session->cb)) {
+			dat[0] = tp_cmd_bam;
+			/* fake cts for broadcast */
+			session->pkt.tx = 0;
+		} else {
+			dat[0] = tp_cmd_rts;
+			dat[4] = dat[3];
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 0, dat);
+		if (ret < 0)
+			goto failed;
+		session->last_txcmd = dat[0];
+		/* must lock? */
+		/*
+		if (tp_cmd_bam == dat[0])
+			j1939tp_schedule_txtimer(session, 50);
+		*/
+		//Initial start to the BAM process
+		if (tp_cmd_bam == dat[0])
+		{
+			printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+			printk("DEBUG: Calling j1939tp_schedule_txtimer\n");
+			//Use  50 ms delay
+			if(j1939cb_use_bamdelay(&tpmod))
+			{
+				printk("DEBUG: Using 50 ms delay\n");
+				j1939tp_schedule_txtimer(session, 50);
+			}
+			//Don't use bam delay
+			else
+			{
+				printk("DEBUG: Using 0 ms delay\n");
+
+				//Start transmit immediately.
+				//TODO: Take in delay value through socket.
+				j1939tp_schedule_txtimer(session, 0);
+			}
+		}
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case tp_cmd_rts:
+	case etp_cmd_rts:
+		if (!j1939tp_im_receiver(session->cb))
+			break;
+tx_cts:
+		ret = 0;
+		len = session->pkt.total - session->pkt.done;
+		if (len > 255)
+			len = 255;
+		if (len > session->pkt.block)
+			len = session->pkt.block;
+		if (block && (len > block))
+			len = block;
+
+		if (session->extd) {
+			pkt = session->pkt.done+1;
+			dat[0] = etp_cmd_cts;
+			dat[1] = len;
+			dat[2] = (pkt >>  0) & 0xff;
+			dat[3] = (pkt >>  8) & 0xff;
+			dat[4] = (pkt >> 16) & 0xff;
+		} else {
+			dat[0] = tp_cmd_cts;
+			dat[1] = len;
+			dat[2] = session->pkt.done+1;
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 1, dat);
+		if (ret < 0)
+			goto failed;
+		if (len)
+			/* only mark cts done when len is set */
+			session->last_txcmd = dat[0];
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case etp_cmd_cts:
+		if (j1939tp_im_transmitter(session->cb) && session->extd &&
+		    (etp_cmd_dpo != session->last_txcmd)) {
+			/* do dpo */
+			dat[0] = etp_cmd_dpo;
+			session->pkt.dpo = session->pkt.done;
+			pkt = session->pkt.dpo;
+			dat[1] = session->pkt.last - session->pkt.done;
+			dat[2] = (pkt >>  0) & 0xff;
+			dat[3] = (pkt >>  8) & 0xff;
+			dat[4] = (pkt >> 16) & 0xff;
+			ret = j1939tp_tx_ctl(session, 0, dat);
+			if (ret < 0)
+				goto failed;
+			session->last_txcmd = dat[0];
+			j1939tp_set_rxtimeout(session, 1250);
+			session->pkt.tx = session->pkt.done;
+		}
+	case tp_cmd_cts:
+	case 0xff: /* did some data */
+	case etp_cmd_dpo:
+		if ((session->extd || !j1939cb_is_broadcast(session->cb)) &&
+		     j1939tp_im_receiver(session->cb)) {
+			if (session->pkt.done >= session->pkt.total) {
+				if (session->extd) {
+					dat[0] = etp_cmd_eof;
+					dat[1] = session->skb->len >> 0;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->skb->len >> 16;
+					dat[4] = session->skb->len >> 24;
+				} else {
+					dat[0] = tp_cmd_eof;
+					dat[1] = session->skb->len;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->pkt.total;
+				}
+				if (dat[0] == session->last_txcmd)
+					/* done already */
+					break;
+				ret = j1939tp_tx_ctl(session, 1, dat);
+				if (ret < 0)
+					goto failed;
+				session->last_txcmd = dat[0];
+				j1939tp_set_rxtimeout(session, 1250);
+				/* wait for the EOF packet to come in */
+				break;
+			} else if (session->pkt.done >= session->pkt.last) {
+				session->last_txcmd = 0;
+				goto tx_cts;
+			}
+		}
+	case tp_cmd_bam:
+		if (!j1939tp_im_transmitter(session->cb))
+			break;
+		tpdat = session->skb->data;
+		ret = 0;
+		pkt_done = 0;
+		pkt_end = (!session->extd && j1939cb_is_broadcast(session->cb))
+			? session->pkt.total : session->pkt.last;
+
+		while (session->pkt.tx < pkt_end)
+		{
+			dat[0] = session->pkt.tx - session->pkt.dpo+1;
+			offset = session->pkt.tx * 7;
+			len = session->skb->len - offset;
+			if (len > 7)
+				len = 7;
+			memcpy(&dat[1], &tpdat[offset], len);
+			ret = j1939tp_tx_dat(session, dat, len+1);
+			if (ret < 0)
+				break;
+			session->last_txcmd = 0xff;
+			++pkt_done;
+			++session->pkt.tx;
+			/*
+			if (j1939cb_is_broadcast(session->cb))
+			{
+				if (session->pkt.tx < session->pkt.total)
+					j1939tp_schedule_txtimer(session, 50);
+				break;
+			}
+			*/
+			if (j1939cb_is_broadcast(session->cb))
+			{
+				if (session->pkt.tx < session->pkt.total)
+				{
+					//Use the normal BAM delay?
+					if(j1939cb_use_bamdelay(&tpmod))
+					{
+						//Send packet after 50 ms
+						j1939tp_schedule_txtimer(session, 50);
+					}
+					else
+					{
+						//Send packet immediately.
+						//TODO: Take in delay value through socket.
+						j1939tp_schedule_txtimer(session, 0);
+					}
+				}
+				break;
+			}
+		}
+		if (pkt_done)
+			j1939tp_set_rxtimeout(session, 250);
+		if (ret)
+			goto failed;
+		break;
+	}
+	put_session(session);
+	return 0;
+failed:
+	put_session(session);
+	return ret;
+}
+
+static void j1939tp_txtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	if (ret < 0)
+		j1939tp_schedule_txtimer(session, retry_ms);
+	put_session(session);
+}
+
+static inline int j1939tp_tx_initial(struct session *session)
+{
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	/* set nonblocking for further packets */
+	session->cb->msg_flags |= MSG_DONTWAIT;
+	put_session(session);
+	return ret;
+}
+
+/* this call is to be used as probe within wait_event_xxx() */
+static int j1939session_insert(struct session *session)
+{
+	struct session *pending;
+
+	sessionlist_lock();
+	pending = _j1939tp_find(sessionq(session->extd), session->cb, 0);
+	if (pending)
+		/* revert the effect of find() */
+		put_session(pending);
+	else
+		list_add_tail(&session->list, sessionq(session->extd));
+	sessionlist_unlock();
+	return pending ? 0 : 1;
+}
+/*
+ * j1939 main intf
+ */
+int j1939_send_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int ret;
+
+	if ((tp_pgn_dat == cb->pgn) || (tp_pgn_ctl == cb->pgn) ||
+	    (etp_pgn_dat == cb->pgn) || (etp_pgn_ctl == cb->pgn))
+		/* avoid conflict */
+		return -EDOM;
+	if (skb->len <= 8)
+		return 0;
+	else if (skb->len > (max_packet_size ?: MAX_ETP_PACKET_SIZE))
+		return -EMSGSIZE;
+
+	if (skb->len > MAX_TP_PACKET_SIZE) {
+		if (j1939cb_is_broadcast(cb))
+			return -EDESTADDRREQ;
+	}
+
+	/* prepare new session */
+	session = j1939session_new(skb);
+	if (!session)
+		return -ENOMEM;
+
+	session->extd = (skb->len > MAX_TP_PACKET_SIZE) ? EXTENDED : REGULAR;
+	session->transmission = 1;
+	session->pkt.total = (skb->len + 6)/7;
+	session->pkt.block = session->extd ? 255 :
+		(block ?: session->pkt.total);
+	if (j1939cb_is_broadcast(session->cb))
+		/* set the end-packet for broadcast */
+		session->pkt.last = session->pkt.total;
+
+	/* insert into queue, but avoid collision with pending session */
+	if (session->cb->msg_flags & MSG_DONTWAIT)
+		ret = j1939session_insert(session) ? 0 : -EAGAIN;
+	else
+		ret = wait_event_interruptible(s.wait,
+				j1939session_insert(session));
+	if (ret < 0)
+		goto failed;
+
+	ret = j1939tp_tx_initial(session);
+	if (!ret)
+		/* transmission started */
+		return RESULT_STOP;
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+failed:
+	/*
+	 * hide the skb from j1939session_drop, as it would
+	 * kfree_skb, but our caller will kfree_skb(skb) too.
+	 */
+	session->skb = NULL;
+	j1939session_drop(session);
+	return ret;
+}
+
+int j1939_recv_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	const uint8_t *dat;
+
+	switch (cb->pgn) {
+	case etp_pgn_dat:
+		j1939xtp_rx_dat(skb, EXTENDED);
+		break;
+	case etp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case etp_cmd_rts:
+			j1939xtp_rx_rts(skb, EXTENDED);
+			break;
+		case etp_cmd_cts:
+			j1939xtp_rx_cts(skb, EXTENDED);
+			break;
+		case etp_cmd_dpo:
+			j1939xtp_rx_dpo(skb, EXTENDED);
+			break;
+		case etp_cmd_eof:
+			j1939xtp_rx_eof(skb, EXTENDED);
+			break;
+		case etp_cmd_abort:
+			j1939xtp_rx_abort(skb, EXTENDED);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		break;
+	case tp_pgn_dat:
+		j1939xtp_rx_dat(skb, REGULAR);
+		break;
+	case tp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case tp_cmd_bam:
+		case tp_cmd_rts:
+			j1939xtp_rx_rts(skb, REGULAR);
+			break;
+		case tp_cmd_cts:
+			j1939xtp_rx_cts(skb, REGULAR);
+			break;
+		case tp_cmd_eof:
+			j1939xtp_rx_eof(skb, REGULAR);
+			break;
+		case tp_cmd_abort:
+			j1939xtp_rx_abort(skb, REGULAR);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		break;
+	default:
+		return 0;
+	}
+	return RESULT_STOP;
+}
+
+static struct session *j1939session_fresh_new(int size,
+		struct j1939_sk_buff_cb *rel_cb, pgn_t pgn)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *cb;
+	struct session *session;
+
+	skb = dev_alloc_skb(size);
+	if (!skb)
+		return NULL;
+	cb = (void *)skb->cb;
+	*cb = *rel_cb;
+	fix_cb(cb);
+	cb->pgn = pgn;
+
+	session = j1939session_new(skb);
+	if (!session) {
+		kfree(skb);
+		return NULL;
+	}
+	/* alloc data area */
+	skb_put(skb, size);
+	return session;
+}
+static struct session *j1939session_new(struct sk_buff *skb)
+{
+	struct session *session;
+
+	session = kzalloc(sizeof(*session), gfp_any());
+	if (!session)
+		return NULL;
+	INIT_LIST_HEAD(&session->list);
+	spin_lock_init(&session->lock);
+	session->skb = skb;
+
+	session->cb = (void *)session->skb->cb;
+	hrtimer_init(&session->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->txtimer.function = j1939tp_txtimer;
+	hrtimer_init(&session->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->rxtimer.function = j1939tp_rxtimer;
+	tasklet_init(&session->txtask, j1939tp_txtask, (unsigned long)session);
+	tasklet_init(&session->rxtask, j1939tp_rxtask, (unsigned long)session);
+	return session;
+}
+
+static int j1939tp_notifier(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *netdev = (struct net_device *)data;
+	struct session *session, *saved;
+
+	if (!net_eq(dev_net(netdev), &init_net))
+		return NOTIFY_DONE;
+
+	if (netdev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	if (msg != NETDEV_UNREGISTER)
+		return NOTIFY_DONE;
+
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &s.sessionq, list) {
+		if (session->cb->ifindex != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &s.extsessionq, list) {
+		if (session->cb->ifindex != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	return NOTIFY_DONE;
+}
+
+/* SYSCTL */
+static struct ctl_table_header *j1939tp_table_header;
+
+static int min_block = 1;
+static int max_block = 255;
+static int min_packet = 8;
+static int max_packet = ((2 << 24)-1)*7;
+
+static int min_retry = 5;
+static int max_retry = 5000;
+
+static ctl_table j1939tp_table[] = {
+	{
+		.procname	= "transport_cts_nr_of_frames",
+		.data		= &block,
+		.maxlen		= sizeof(block),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &min_block,
+		.extra2		= &max_block,
+	},
+	{
+		.procname	= "transport_max_payload_in_bytes",
+		.data		= &max_packet_size,
+		.maxlen		= sizeof(max_packet_size),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &min_packet,
+		.extra2		= &max_packet,
+	},
+	{
+		.procname	= "transport_tx_retry_ms",
+		.data		= &retry_ms,
+		.maxlen		= sizeof(retry_ms),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &min_retry,
+		.extra2		= &max_retry,
+	},
+	{ },
+};
+
+static struct ctl_path j1939tp_path[] = {
+	{ .procname = "net", },
+	{ .procname = j1939_procname, },
+	{ }
+};
+
+/* PROC */
+static int j1939tp_proc_show_session(struct seq_file *sqf,
+		struct session *session)
+{
+	seq_printf(sqf, "%i", session->cb->ifindex);
+	if (session->cb->src.name)
+		seq_printf(sqf, "\t%016llx", session->cb->src.name);
+	else
+		seq_printf(sqf, "\t%02x", session->cb->src.addr);
+	if (session->cb->dst.name)
+		seq_printf(sqf, "\t%016llx", session->cb->dst.name);
+	else if (j1939_address_is_unicast(session->cb->dst.addr))
+		seq_printf(sqf, "\t%02x", session->cb->dst.addr);
+	else
+		seq_printf(sqf, "\t-");
+	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
+			session->pkt.done*7, session->skb->len);
+	return 0;
+}
+
+static int j1939tp_proc_show(struct seq_file *sqf, void *v)
+{
+	struct session *session;
+
+	seq_printf(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
+	sessionlist_lock();
+	list_for_each_entry(session, &s.sessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	list_for_each_entry(session, &s.extsessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	sessionlist_unlock();
+	return 0;
+}
+
+int __init j1939tp_module_init(void)
+{
+	spin_lock_init(&s.lock);
+	INIT_LIST_HEAD(&s.sessionq);
+	INIT_LIST_HEAD(&s.extsessionq);
+	spin_lock_init(&s.del.lock);
+	INIT_LIST_HEAD(&s.del.sessionq);
+	INIT_WORK(&s.del.work, j1939tp_del_work);
+
+	s.notifier.notifier_call = j1939tp_notifier;
+	register_netdevice_notifier(&s.notifier);
+
+	j1939_proc_add("transport", j1939tp_proc_show, NULL);
+	j1939tp_table_header =
+		register_sysctl_paths(j1939tp_path, j1939tp_table);
+	init_waitqueue_head(&s.wait);
+	return 0;
+}
+
+void j1939tp_module_exit(void)
+{
+	struct session *session, *saved;
+
+	wake_up_all(&s.wait);
+
+	unregister_sysctl_table(j1939tp_table_header);
+	unregister_netdevice_notifier(&s.notifier);
+	j1939_proc_remove("transport");
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &s.extsessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &s.sessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	flush_scheduled_work();
+}
+
